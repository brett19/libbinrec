/*
 * libbinrec: a recompiling translator for machine code
 * Copyright (c) 2016 Andrew Church <achurch@achurch.org>
 *
 * This software may be copied and redistributed under certain conditions;
 * see the file "COPYING" in the source code distribution for details.
 * NO WARRANTY is provided with this software.
 */

#ifndef BINREC_H
#define BINREC_H

#include <stddef.h>
#include <stdint.h>

#ifdef __cplusplus
extern "C" {
#endif

/*
 * General notes
 * =============
 *
 * In this header (and the library source code in general), "guest" refers
 * to the source CPU or architecture, i.e. the input to the translator, and
 * "host" or "native" refers to the target CPU or architecture, i.e. the
 * output of the translator.  A program which calls into code generated by
 * this library is referred to as a "client program".
 *
 * The numeric values of constants and the layout of structures in this
 * header are _not_ part of the public API; always use the symbolic names
 * rather than the numeric values or offsets when writing code which
 * interfaces to the library.  The library ABI (including those values and
 * offsets) will be kept consistent through revisions of a major version,
 * such that a program compiled against library version x.y (x >= 1) will
 * also run correctly using library version x.z (z > y), but the ABI may
 * change between major versions, or at any time before version 1.0.
 *
 *
 * Guest-specific notes
 * ====================
 *
 * The abbreviation "PSB" below refers to the processor state block, i.e.
 * the structure containing the current state of the guest processor.
 *
 * libbinrec is designed to allow a certain amount of flexibility in the
 * structure of the PSB.  The binrec_setup_t structure includes several
 * "state_offset_*" fields for specifying the byte offset of various
 * members of the PSB; the client program should set those fields to the
 * relevant offsets within its PSB structure.
 *
 * PowerPC 32-bit architectures (BINREC_ARCH_PPC_7XX)
 * --------------------------------------------------
 * Floating-point registers in the PSB are assumed to be stored as pairs
 * of 64-bit floating point ("double"-type) values, with the first value
 * of each pair holding the value of that register as a scalar or the ps0
 * slot of the register for paired-single mode, and the second value of
 * each pair holding the value of the ps1 slot for paired-single mode.
 * The translated code will take care of converting between single and
 * double precision as needed.
 *
 * The client program is responsible for setting the host's floating-point
 * rounding mode based on FPSCR[RN] and clearing any pending floating-point
 * exceptions before calling translated code.
 *
 * The conditional load/store instructions (lwarx and stwcx.) rely on
 * hardware support for their behavior.  Since such hardware support is
 * not necessarily available in the host environment, and since a correct
 * implementation requires knowledge of that environment which is not
 * available to libbinrec, these instructions are implemented using a
 * compare-and-swap heuristic: an stwcx. after a lwarx succeeds if the
 * value at the target address is unchanged from the value it had when the
 * lwarx was executed.  Translated code for lwarx and stwcx makes use of
 * two PSB fields: reserve_flag (an 8-bit Boolean value), which records
 * whether an lwarx is pending, and reserve_state (a 32-bit integer value),
 * which stores the value loaded by the most recent lwarx.  This can result
 * in incorrect behavior if the guest code expects the store to fail due to
 * writes of an identical value or writes a new value using a regular store
 * between the conditional load and store, but this heuristic should
 * suffice for typical programs.  Note that the address of the lwarx is
 * _not_ saved; a stwcx. to a different address will still succeed if that
 * address contains the same value as was loaded by the lwarx instruction.
 * (This matches the behavior of actual PowerPC CPUs in the sense that
 * address mismatches between lwarx and stwcx. are ignored.)
 *
 * Access to the time base registers via the mftb instruction is
 * implemented by calling a host-side callback function, a pointer to
 * which should be stored in the PSB at the offset indicated by
 * state_offset_timebase_handler.  The signature of the function is
 * "uint64_t handler(PSB *)", taking the pointer to the PSB which was
 * passed to the translated code and returning the current 64-bit time
 * base value.  If the function pointer is NULL, reads of the time base
 * registers will always return zero.
 *
 * Exceptions generated by the system call (sc) and trap (tw/twi)
 * instructions are implemented as control transfers to host-side
 * functions, pointers to which should be stored in the PSB at the offsets
 * indicated by state_offset_sc_handler and state_offset_trap_handler
 * respectively.  The signature of the functions is "void handler(PSB *)",
 * taking the pointer to the PSB which was passed to the translated code.
 * The value of the NIA field in the PSB is set as the SRR0 register would
 * be set on a true PowerPC processor: to the address of the trap
 * instruction for trap exceptions, and to the address of the instruction
 * _following_ the sc instruction for system call exceptions (however, the
 * sequence "sc; blr" is optimized by setting NIA to the value of LR when
 * calling the system call handler).  The translated code will return
 * immediately to its caller when the handler returns.  The translated
 * code does not check for NULL function pointers, so it will crash if an
 * exception occurs and the associated function pointer is not set.
 *
 * All instruction words with the primary opcode of the sc instruction
 * (0x11) are decoded as that instruction.  This deviates from the PowerPC
 * specification, in which only the instruction 0x4400_0002 is a valid sc
 * instruction, but is done to allow the use of that instruction as (for
 * example) a callout to native code in a PowerPC system emulator.
 *
 * If D-form (immediate offset) load or store instruction has an offset
 * which causes the final address to wrap around the 32-bit address space,
 * such as lwz rD,16(rA) where the value of rA is 0xFFFFFFF0 or greater,
 * the access will improperly "leak" outside the guest memory region.
 * However, accesses to the top 32k of memory using single-register (not
 * lmw/stmw) D-form instructions with rA = 0 are handled correctly.
 */

/*************************************************************************/
/*********************** Data types and constants ************************/
/*************************************************************************/

/*----------------------------- Basic types -----------------------------*/

/**
 * binrec_t:  Type of a translation handle.  This handle stores global
 * translation settings, such as optimization flags and functions to use
 * for memory allocation.
 */
typedef struct binrec_t binrec_t;

/**
 * binrec_arch_t:  Enumeration of architectures and variants supported by
 * the library.  All currently supported architectures are either
 * guest-only or host-only; see the inline comments at each enumerator.
 *
 * As a general rule, libbinrec assumes that its input is a program
 * designed to run on the selected guest architecture, and therefore all
 * instructions encountered in the program will be valid instruction
 * encodings.  Consequently, this enumeration only includes coarse
 * architecture families which encompass a group of compatible processors;
 * for example, the PPC_7XX architecture covers all PowerPC CPUs through
 * the 750CL, and the input program is assumed to use only instructions
 * which are valid on the architecture it was written for. See also the
 * note on library limitations in the README file.
 */
typedef enum binrec_arch_t {
    /* Constant used to indicate an unsupported architecture by
     * binrec_native_arch(). */
    BINREC_ARCH_INVALID = 0,

    /* PowerPC 32-bit architecture as implemented in PowerPC 7xx
     * processors, including all other instruction set extensions through
     * the PowerPC 750CL.  Also supports programs written for PowerPC 6xx
     * CPUs, with the exception of non-PowerPC instructions (such as ABS)
     * specific to the PowerPC 601. */
    BINREC_ARCH_PPC_7XX,                // Guest only.

    /* Intel/AMD x86 64-bit architecture, using the SysV ABI. */
    BINREC_ARCH_X86_64_SYSV,            // Host only.

    /* Intel/AMD x86 64-bit architecture, using the Windows ABI. */
    BINREC_ARCH_X86_64_WINDOWS,         // Host only.

    /* Variant of BINREC_ARCH_X86_64_WINDOWS which prepends unwind
     * information to the returned function.  The offset to the generated
     * code is stored as a 64-bit value at the returned code address, and
     * the unwind information is found immediately after that value. */
    BINREC_ARCH_X86_64_WINDOWS_SEH,     // Host only.
} binrec_arch_t;

/**
 * binrec_loglevel_t:  Enumeration of log levels which can be passed to
 * the log function specified in binrec_setup_t.
 */
typedef enum binrec_loglevel_t {
    BINREC_LOGLEVEL_INFO,    // Informational messages.
    BINREC_LOGLEVEL_WARNING, // Messages indicating a potential problem.
    BINREC_LOGLEVEL_ERROR,   // Messages indicating failure of some operation.
} binrec_loglevel_t;

/*--------------------- Architecture feature flags ----------------------*/

/*
 * These flags indicate the presence of specific features (such as optional
 * instructions) within a particular architecture.  These are used in the
 * "host_features" field of binrec_setup_t.
 */

/**
 * BINREC_FEATURE_X86_*:  Feature flags for the x86 architecture.
 */
#define BINREC_FEATURE_X86_FMA      (1U << 0)
#define BINREC_FEATURE_X86_MOVBE    (1U << 1)
#define BINREC_FEATURE_X86_POPCNT   (1U << 2)
#define BINREC_FEATURE_X86_AVX      (1U << 3)
#define BINREC_FEATURE_X86_LZCNT    (1U << 4)  // a.k.a. ABM
#define BINREC_FEATURE_X86_BMI1     (1U << 5)
#define BINREC_FEATURE_X86_AVX2     (1U << 6)
#define BINREC_FEATURE_X86_BMI2     (1U << 7)

/*--------------------------- Setup structure ---------------------------*/

/**
 * binrec_setup_t:  Structure which defines various parameters used by the
 * translator.  Used by binrec_create_handle().
 */
typedef struct binrec_setup_t {

    /**
     * guest, host:  BINREC_ARCH_* values indicating the architecture and
     * variant to translate from (guest) and to (host).  binrec_translate()
     * will fail if the library cannot perform the requested translation.
     */
    binrec_arch_t guest;
    binrec_arch_t host;

    /**
     * host_features:  Bitwise-OR of feature flags for the selected host
     * architecture, indicating which features should be assumed to be
     * present for host code generation.
     */
    unsigned int host_features;

    /**
     * guest_memory_base:  Pointer to a region of host memory reserved as
     * the address space of the guest code.  binrec_translate() calls will
     * read source machine instructions and constand data from this region.
     * Memory accesses within the translated code itself will use the
     * address in host_memory_base, defined below.
     */
    void *guest_memory_base;

    /**
     * host_memory_base:  Base address in the host environment of the
     * memory region reserved as the address space of the guest code.
     * Generated host machine code will perform loads and stores by adding
     * the target address to this value.  The program calling the
     * translated code is responsible for correctly mapping the parts of
     * this region corresponding to valid guest memory and for handling
     * any invalid-access exceptions which occur during execution (such as
     * loads or stores with an invalid address).
     *
     * In a typical JIT translation environment, this will have the same
     * numeric value as guest_memory_base, but in certain usage patterns
     * it can be useful to set a different address here than the pointer
     * used to read instructions at translation time.
     */
    uint64_t host_memory_base;

    /**
     * state_offset_*:  Offsets from the beginning of the processor state
     * block (as passed to the generated native code) to the various guest
     * registers and other processor state.  Each block of registers is
     * assumed to be contiguous; for example, GPR 1 is accessed by loading
     * a 32-bit value from state_offset_gpr + 4.  All multi-byte values are
     * assumed to be stored in host endian order.
     * FIXME: Generalize for non-PPC guests.
     */
    /* General-purpose registers (32 * uint32_t) */
    int state_offset_gpr;
    /* Floating-point registers (32 * double[2]) */
    int state_offset_fpr;
    /* Paired-single quantization registers (8 * uint32_t) */
    int state_offset_gqr;
    /* Miscellaneous registers (each uint32_t) */
    int state_offset_lr;
    int state_offset_ctr;
    int state_offset_cr;
    int state_offset_xer;
    int state_offset_fpscr;
    /* lwarx/stwcx. reservation flag (uint8_t) */
    int state_offset_reserve_flag;
    /* lwarx/stwcx. reservation state (uint32_t) */
    int state_offset_reserve_state;
    /* Next instruction address (updated on return from translated code) */
    int state_offset_nia;
    /* Pointer to function to handle time base reads.  Signature:
     * uint64_t timebase_handler(void *state) */
    int state_offset_timebase_handler;
    /* Pointer to function to handle system calls (sc instruction).
     * Signature: void sc_handler(void *state) */
    int state_offset_sc_handler;
    /* Pointer to function to handle trap exceptions.  Signature:
     * void trap_handler(void *state) */
    int state_offset_trap_handler;
    /* Pointer to function to call at intra-unit branches (see
     * binrec_enable_branch_callback()).  Signature:
     * int branch_callback(void *state, uint32_t branch_address) */
    int state_offset_branch_callback;

    /**
     * userdata:  Opaque pointer which is passed to all callback functions
     * below.
     */
    void *userdata;

    /**
     * malloc:  Pointer to a function which allocates memory, like malloc().
     * If NULL, the system's malloc() will be used.
     *
     * Like standard malloc(), this function may return either NULL or a
     * pointer to a zero-size memory block if passed a size of zero.
     *
     * [Parameters]
     *     userdata: User data pointer from setup structure.
     *     size: Size of block to allocate, in bytes.
     * [Return value]
     *     Pointer to allocated memory, or NULL on error or if size == 0.
     */
    void *(*malloc)(void *userdata, size_t size);

    /**
     * realloc:  Pointer to a function which resizes a block of allocated
     * memory, like realloc().  If NULL, the system's realloc() will be used.
     *
     * Like standard realloc(), this function may return either NULL or a
     * pointer to a zero-size memory block if passed a size of zero.
     *
     * [Parameters]
     *     userdata: User data pointer from setup structure.
     *     ptr: Block to resize, or NULL to allocate a new block.
     *     size: New size of block, in bytes, or 0 to free the block.
     * [Return value]
     *     Pointer to allocated memory, or NULL on error or if size == 0.
     */
    void *(*realloc)(void *userdata, void *ptr, size_t size);

    /**
     * free:  Pointer to a function which frees a block of allocated
     * memory, like free().  If NULL, the system's free() will be used.
     *
     * [Parameters]
     *     userdata: User data pointer from setup structure.
     *     ptr: Block to free (may be NULL).
     * [Return value]
     *     Pointer to allocated memory, or NULL on error.
     */
    void (*free)(void *userdata, void *ptr);

    /**
     * code_malloc:  Pointer to a function which allocates a block of
     * memory for output machine code.  If NULL, the malloc() callback (or
     * the system's malloc(), if that callback is also NULL) will be used
     * and no alignment will be performed.
     *
     * [Parameters]
     *     userdata: User data pointer from setup structure.
     *     size: Size of block to allocate, in bytes (guaranteed to be
     *         nonzero).
     *     alignment: Desired address alignment, in bytes (guaranteed to
     *         be a power of 2).
     * [Return value]
     *     Pointer to allocated memory, or NULL on error.
     */
    void *(*code_malloc)(void *userdata, size_t size, size_t alignment);

    /**
     * code_realloc:  Pointer to a function which resizes a block of memory
     * allocated with the code_malloc() callback.  If NULL, the realloc()
     * callback (or the system's realloc(), if that callback is also NULL)
     * will be used.
     *
     * [Parameters]
     *     userdata: User data pointer from setup structure.
     *     ptr: Block to resize (guaranteed to be non-NULL).
     *     old_size: Current size of block, in bytes.
     *     new_size: New size of block, in bytes (guaranteed to be nonzero).
     *     alignment: Required address alignment, in bytes (guaranteed to
     *         be equal to the value used for initial allocation).
     * [Return value]
     *     Pointer to allocated memory, or NULL on error.
     */
    void *(*code_realloc)(void *userdata, void *ptr, size_t old_size,
                          size_t new_size, size_t alignment);

    /**
     * code_free:  Pointer to a function which frees a block of memory
     * allocated with the code_malloc() callback.  If NULL, the free()
     * callback (or the system's free(), if that callback is also NULL)
     * will be used.
     *
     * [Parameters]
     *     userdata: User data pointer from setup structure.
     *     ptr: Block to free (may be NULL).
     */
    void (*code_free)(void *userdata, void *ptr);

    /**
     * log:  Pointer to a function to log messages from the library.
     * If NULL, no logging will be performed.
     *
     * [Parameters]
     *     userdata: User data pointer from setup structure.
     *     level: Log level (BINREC_LOGLEVEL_*).
     *     message: Log message.
     */
    void (*log)(void *userdata, binrec_loglevel_t level, const char *message);

} binrec_setup_t;

/*--------------------- General optimization flags ----------------------*/

/*
 * Optimizations performed by the library can generally be classified into
 * three types:
 *
 * - Behavior-safe: optimizations which purely affect the size or speed of
 *   the generated code and have no effect on behavior.  Optimizations
 *   such as constant folding and deconditioning fall into this category.
 *   Optimizations can be assumed to fall under this category where not
 *   otherwise documented.
 *
 * - Specification-safe: optimizations which may change the behavior of
 *   the generated code, but only within limits prescribed by the relevant
 *   specification.  For example, the NATIVE_IEEE_TINY optimization may
 *   change the results of certain floating-point operations relative to
 *   the results returned by guest code running on its native hardware,
 *   but the IEEE floating-point specification allows either of two
 *   behaviors, so with respect to that specification, the optimized code
 *   is no less correct than the original.  As long as the guest code was
 *   written to follow the specifications rather than the precise behavior
 *   of the guest hardware, it will still behave correctly under these
 *   optimizations.
 *
 * - Unsafe: optimizations which can materially impact the behavior of the
 *   generated code, such as stack frame optimization.  These optimizations
 *   can benefit code which rigorously adhere to the relevant assumptions,
 *   such as code produced by a high-level language compiler, but they can
 *   cause nonconformant code to misbehave or even crash.  Documentation
 *   for an unsafe optimization will clearly indicate that fact.
 */

/**
 * BINREC_OPT_BASIC:  Enable basic optimization of translated code.  This
 * includes the following transformations:
 *
 * - Branches to other (unconditional or same-conditioned) branch
 *   instructions will be threaded through to the final branch destination.
 *
 * - Unreachable basic blocks will be eliminated from the code stream.
 *
 * - Branches to the next instruction will be eliminated.
 */
#define BINREC_OPT_BASIC  (1<<0)

/**
 * BINREC_OPT_CALLEE_SAVED_REGS:  Assume that registers specified as
 * callee-saved by the guest ABI are not modified across a subroutine call
 * or system call instruction, and if the instruction can be translated to
 * a native subroutine call, do not flush those registers to the processor
 * state block before the call or reload them after the call.
 *
 * This optimization has no effect unless BINREC_OPT_NATIVE_CALLS is also
 * enabled.  This optimization is also irrelevant for inlined functions;
 * register live ranges will be correctly calculated for all registers
 * when a function is inlined.
 *
 * This optimization is UNSAFE: if the assumption described above is
 * violated by guest code, the translated code will not behave correctly.
 *
 * This optimization is not currently implemented.
 */
#define BINREC_OPT_CALLEE_SAVED_REGS  (1<<1)

/**
 * BINREC_OPT_DECONDITION:  Convert conditional branches and moves with
 * constant conditions to unconditional instructions or NOPs.  This is
 * most useful in conjunction with constant folding.
 */
#define BINREC_OPT_DECONDITION  (1<<2)

/**
 * BINREC_OPT_DEEP_DATA_FLOW:  Perform extended data flow analysis on
 * values associated with guest architecture registers to find dead stores.
 * This optimization by itself only finds dead stores; enable BINREC_OPT_DSE
 * to remove them from the code stream.
 */
#define BINREC_OPT_DEEP_DATA_FLOW  (1<<3)

/**
 * BINREC_OPT_DSE:  Perform dead store elimination (DSE) on the translated
 * code, removing instructions whose outputs are not used.
 */
#define BINREC_OPT_DSE  (1<<4)

/**
 * BINREC_OPT_FOLD_CONSTANTS:  Look for computations whose operands are all
 * constant and load operations which load from a constant address within
 * memory marked read-only (see binrec_add_readonly_region()), and convert
 * them to load-immediate operations.  The computed values are themselves
 * treated as constant, so constantness can be propagated through multiple
 * instructions.  Intermediate values in a computation sequence which end
 * up being unused due to constant folding, as well as any other
 * instructions whose outputs which are not used elsewhere, are removed
 * from the code stream if BINREC_OPT_DSE is also enabled.
 */
#define BINREC_OPT_FOLD_CONSTANTS  (1<<5)

/**
 * BINREC_OPT_FOLD_FP_CONSTANTS:  Fold floating-point as well as integer
 * constants, performing the floating-point operations in the runtime
 * environment.  Any floating-point exceptions generated by the operation
 * are discarded.
 *
 * This flag is ignored if BINREC_OPT_FOLD_CONSTANTS is not also set.
 *
 * This optimization is UNSAFE: if the floating-point behavior of the
 * runtime environment differs materially from that of the guest
 * architecture (such as by not complying with IEEE 754) or if a folded
 * operation generates a floating-point exception and the guest code
 * expects to detect that exception, the translated code will not behave
 * correctly.
 */
#define BINREC_OPT_FOLD_FP_CONSTANTS  (1<<6)

/**
 * BINREC_OPT_NATIVE_CALLS:  Treat subroutine-call instructions (like x86
 * CALL or PowerPC BL) as instructions with side effects rather than
 * branches, by translating them into native subroutine-call instructions.
 *
 * This optimization can significantly improve the performance of non-leaf
 * functions by allowing larger parts of the function to be translated as
 * a single unit.
 *
 * This optimization is behavior-safe in the narrow sense that it does not
 * change the meaning of the code, but code which uses call instructions in
 * nonstandard ways (such as a call to the next instruction to obtain the
 * instruction's address) can potentially cause a host stack overflow if
 * executed too often without returning control to the client program.
 *
 * This optimization is not currently implemented.
 */
#define BINREC_OPT_NATIVE_CALLS  (1<<7)

/**
 * BINREC_OPT_NATIVE_IEEE_NAN:  Use the host's rules for NaN results of
 * floating-point operations, even when those rules differ from the guest
 * architecture.
 *
 * The IEEE specification allows differing behavior between implementations
 * in the following cases:
 *
 * - If more than one operand to an operation is a NaN, the returned NaN
 *   may be any of those values.
 *
 * - If a NaN is generated due to an invalid operation, its bit pattern
 *   may be any quiet NaN bit pattern.
 *
 * This optimization allows the translator to translate floating-point
 * operations directly to their host equivalents without manually checking
 * for NaNs, which can require several additional host instructions per
 * guest instruction.
 *
 * This optimization is specification-safe: as long as guest code follows
 * the IEEE 754 specifications, it will behave correctly under this
 * optimization.
 *
 * This optimization cannot currently be disabled; the translator behaves
 * as if it was always set.
 */
#define BINREC_OPT_NATIVE_IEEE_NAN  (1<<8)

/**
 * BINREC_OPT_NATIVE_IEEE_TINY:  Use the host's definition of "tiny" for
 * IEEE floating-point arithmetic, even when that differs from the guest
 * definition.
 *
 * When translating between architectures which use different definitions
 * of "tiny" (IEEE allows two different behaviors: tiny before rounding
 * and tiny after rounding), this optimization allows floating-point
 * operations to be translated directly to their equivalent host
 * instructions, at the cost of slightly different results for operations
 * with a result which is treated as "tiny" on one architecture and not
 * the other.  If this optimization is disabled, floating-point operations
 * must check explicitly for a "tiny" result, which can require several
 * additional host instructions per guest instruction.
 *
 * If the host and guest use the same "tiny" rules, floating-point
 * operations can always be translated directly to native instructions
 * (at least with regard to tininess), and this flag has no effect on
 * translation.
 *
 * This optimization is specification-safe: as long as guest code follows
 * the IEEE 754 specifications, it will behave correctly under this
 * optimization.
 *
 * This optimization cannot currently be disabled; the translator behaves
 * as if it was always set.
 */
#define BINREC_OPT_NATIVE_IEEE_TINY  (1<<9)

/**
 * BINREC_OPT_STACK_FRAMES:  Assume that a given function's stack frame is
 * only stored to by that function (unless it passes a stack-based pointer
 * to another function), and translate store/load instruction pairs on the
 * same stack frame location (such as when saving and restoring
 * callee-saved registers, or loading a spilled temporary register) to a
 * register move or no-op.
 *
 * If the function passes a stack-based pointer to another function
 * (specifically, if a value derived from the stack pointer register is
 * live in a register or stored to a function argument slot on the stack),
 * this optimization will be disabled for that function.  This optimization
 * only takes effect when both store and load are in the same translation
 * unit, so it will have limited benefit unless BINREC_OPT_NATIVE_CALLS is
 * also enabled.
 *
 * This optimization is UNSAFE: if the assumption described above is
 * violated by guest code, the translated code will not behave correctly.
 *
 * This optimization is not currently implemented.
 */
#define BINREC_OPT_STACK_FRAMES  (1<<10)

/*----------- Guest-architecture-specific optimization flags ------------*/

/**
 * BINREC_OPT_G_PPC_CONSTANT_GQRS:  Assume that the values of the GQRs
 * (graphics quantization registers, used with paired-single load and
 * store instructions) are constant with respect to the entry point of a
 * translation unit.
 *
 * If this optimization is enabled, the translator will (at translation
 * time) read the values of any GQRs referenced by guest code and
 * translate paired-single load and store instructions to appropriate host
 * instructions based on those values.  Otherwise, the translated host
 * code will read the GQRs and choose an appropriate load or store
 * operation at runtime, which is typically more than an order of
 * magnitude slower.
 *
 * If guest code modifies a GQR and then performs a paired-single load or
 * store based on that GQR, the translated code will take the new value of
 * the GQR into account; if the value written to the GQR is not a constant
 * or if the GQR is only set conditionally, this optimization will be
 * effectively disabled for the remainder of the translation unit.
 *
 * This optimization is UNSAFE: if the assumption described above is
 * violated by guest code, the translated code will not behave correctly.
 *
 * This optimization is not currently implemented.
 */
#define BINREC_OPT_G_PPC_CONSTANT_GQRS  (1<<0)

/**
 * BINREC_OPT_G_PPC_IGNORE_FPSCR_FR:  Do not set the FR bit of FPSCR after
 * floating-point operations.
 *
 * Properly emulating FPSCR[FR] in software requires performing each
 * operation twice to check the rounding direction, with rounding mode
 * changes between each operation; this naturally has a severe impact on
 * performance of floating-point-heavy code.  Enabling this optimization
 * allows the translator to skip those extra operations.  Instructions
 * which directly manipulate FPSCR (such as mtfsf) are not affected by
 * this optimization and continue to behave normally.
 *
 * This optimization is UNSAFE for obvious reasons, though it is believed
 * that most real-life PowerPC code does not make use of the FR bit.
 *
 * This optimization cannot currently be disabled; the translator behaves
 * as if it was always set.
 */
#define BINREC_OPT_G_PPC_IGNORE_FPSCR_FR  (1<<1)

/**
 * BINREC_OPT_G_PPC_NATIVE_RECIPROCAL:  Translate guest PowerPC
 * reciprocal-estimate instructions (fres and frsqrte) directly to their
 * host equivalents, maintaining compliance with the PowerPC architecture
 * specification but disregarding the precise behavior of the guest
 * architecture.
 *
 * The PowerPC architecture specifies bounds within which the results of
 * these instructions will fall relative to the true (mathematical) result.
 * Programs written to be compliant with the architecture will work
 * correctly regardless of the exact output of the instruction, though the
 * precise behavior of the program (for example, the low-end bits of the
 * result) may change.  This flag allows the translator to choose faster
 * host instructions which may not give exactly the same result but still
 * satisfy the PowerPC architecture constraints.
 *
 * If this optimization is disabled, the translator will attempt to match
 * the precise behavior of the guest architecture, at the cost of several
 * additional host instructions per affected guest instruction.
 *
 * This optimization cannot currently be disabled; the translator behaves
 * as if it was always set.
 */
#define BINREC_OPT_G_PPC_NATIVE_RECIPROCAL  (1<<2)

/**
 * BINREC_OPT_G_PPC_TRIM_CR_STORES:  Analyze the data flow through each
 * CR bit and eliminate stores which are not visible outside the
 * translated code.
 *
 * If this optimization is enabled, pre- and post-instruction callbacks,
 * branch callbacks, and timebase handlers may see incorrect values of CR
 * in the processor state block.  System call and trap handlers are not
 * affected.
 */
#define BINREC_OPT_G_PPC_TRIM_CR_STORES  (1<<3)

/*------------ Host-architecture-specific optimization flags ------------*/

/**
 * BINREC_OPT_H_X86_ADDRESS_OPERANDS:  Encode certain address calculations
 * directly in a load, store, or atomic instruction when feasible.  If the
 * address operand of such an instruction is not referenced by any other
 * instruction (after the one that sets it), then:
 *
 * - If the address is the sum of a register and a constant, and the sum of
 *   that constant and the offset encoded in the instruction is within the
 *   range of a 32-bit signed integer, eliminate the addition and use the
 *   combined offset as the access offset in the instruction.
 *
 * - If the address is the sum of two registers, eliminate the addition and
 *   encode the access using the base-plus-index format.
 */
#define BINREC_OPT_H_X86_ADDRESS_OPERANDS  (1<<0)

/**
 * BINREC_OPT_H_X86_BRANCH_ALIGNMENT:  Align branch targets to a multiple
 * of 16 bytes by inserting NOP instructions at appropriate points in the
 * generated code stream.
 */
#define BINREC_OPT_H_X86_BRANCH_ALIGNMENT  (1<<1)

/**
 * BINREC_OPT_H_X86_CONDITION_CODES:  Track the state of the condition
 * codes in the EFLAGS register, and avoid adding an explicit TEST or CMP
 * instruction for a register if the condition codes already reflect the
 * value of that register.
 */
#define BINREC_OPT_H_X86_CONDITION_CODES  (1<<2)

/**
 * BINREC_OPT_H_X86_FIXED_REGS:  When an instruction requires an operand to
 * be in a specific hardware register (shift counts must be in CL, for
 * example), try harder to allocate that hardware register for the operand.
 * This requires an extra pass over the translated machine code during
 * register allocation.
 */
#define BINREC_OPT_H_X86_FIXED_REGS  (1<<3)

/**
 * BINREC_OPT_H_X86_FORWARD_CONDITIONS:  When a register used as the
 * condition for a conditional branch or move is the result of a comparison
 * instruction and that register is not used elsewhere, eliminate the
 * register and forward the comparison condition to the branch or move
 * instruction.
 */
#define BINREC_OPT_H_X86_FORWARD_CONDITIONS  (1<<4)

/**
 * BINREC_OPT_H_X86_MERGE_REGS:  Try harder to avoid moving values
 * between registers.
 */
#define BINREC_OPT_H_X86_MERGE_REGS  (1<<5)

/**
 * BINREC_OPT_H_X86_STORE_IMMEDIATE:  When an immediate value is used only
 * as the data for a store operation, encode the immediate value directly
 * in the instruction instead of using a register.
 */
#define BINREC_OPT_H_X86_STORE_IMMEDIATE  (1<<6)

/*************************************************************************/
/******** Interface: Library and runtime environment information *********/
/*************************************************************************/

/**
 * binrec_version:  Return the version number of the library as a string
 * (for example, "1.2.3").
 *
 * [Return value]
 *     Library version number.
 */
extern const char *binrec_version(void);

/**
 * binrec_native_arch:  Return a BINREC_ARCH_* constant representing the
 * architecture of the runtime environment, or 0 (BINREC_ARCH_INVALID) if
 * the runtime environment does not correspond to a supported host
 * architecture.  (If a nonzero value is returned, it will always be valid
 * as a host architecture for translation.)
 *
 * [Return value]
 *     Runtime environment architecture (BINREC_ARCH_*), or 0 if unsupported.
 */
extern binrec_arch_t binrec_native_arch(void);

/**
 * binrec_native_features:  Return a bitmask of architecture features
 * (BINREC_FEATURE_*) supported by the runtime environment, or 0 if the
 * runtime environment does not correspond to a supported architecture.
 *
 * [Return value]
 *     Runtime environment feature bitmap, or 0 if unsupported.
 */
extern unsigned int binrec_native_features(void);

/**
 * binrec_guest_supported:  Return whether the given architecture is
 * supported as a guest architecture for translation.
 *
 * [Parameters]
 *     arch: Architecture to check.
 * [Return value]
 *     True (nonzero) if the given architecture is supported as a guest
 *     architecture, false (zero) if not.
 */
extern int binrec_guest_supported(binrec_arch_t arch);

/**
 * binrec_host_supported:  Return whether the given architecture is
 * supported as a guest architecture for translation.
 *
 * [Parameters]
 *     arch: Architecture to check.
 * [Return value]
 *     True (nonzero) if the given architecture is supported as a guest
 *     architecture, false (zero) if not.
 */
extern int binrec_host_supported(binrec_arch_t arch);

/*************************************************************************/
/*************** Interface: Translation handle management ****************/
/*************************************************************************/

/**
 * binrec_create_handle:  Create a new translation handle.
 *
 * [Parameters]
 *     setup: Pointer to a binrec_setup_t structure that defines the
 *         translation parameters to use.
 * [Return value]
 *     Newly created handle, or NULL on error.
 */
extern binrec_t *binrec_create_handle(const binrec_setup_t *setup);

/**
 * binrec_destroy_handle:  Destroy a translation handle.
 *
 * This function only destroys the translation handle itself; blocks of
 * translated code generated through the handle remain valid even after
 * the handle is destroyed.
 *
 * [Parameters]
 *     handle: Handle to destroy (may be NULL).
 */
extern void binrec_destroy_handle(binrec_t *handle);

/**
 * binrec_set_code_range:  Set the minimum and maximum addresses from which
 * to read source machine instructions.  Branch instructions which attempt
 * to jump outside this range will terminate the translation unit, and if
 * the source machine code runs off the end of the range, the unit will be
 * terminated at the final instruction completely contained within the range.
 * The range must not wrap around the end of the address space.
 *
 * By default, the entire address space is considered valid for reading
 * instructions.
 *
 * Note that binrec_translate() also allows specifying an address range for
 * translation.  This function is intended more for the purpose of avoiding
 * translation of memory areas known to be outside the bounds of the input
 * program code, such as data segments or undefined memory, similar to the
 * "execute" permission bit in hardware memory management units.  (It is
 * not currently possible to specify multiple disjoint code ranges.)
 *
 * [Parameters]
 *     handle: Handle to operate on.
 *     start: First address of code range.
 *     end: Last address of code range (inclusive).
 */
extern void binrec_set_code_range(binrec_t *handle, uint32_t start,
                                  uint32_t end);

/**
 * binrec_set_optimization_flags:  Set which optimizations should be
 * performed on translated blocks.  Enabling more optimizations will
 * improve the performance of translated code but increase the overhead
 * of translation; see the documentation on each optimization flag for
 * details.
 *
 * The set of enabled optimizations may be changed at any time without
 * impacting the behavior of already-translated blocks.
 *
 * By default, no optimizations are enabled.
 *
 * [Parameters]
 *     handle: Handle to operate on.
 *     common_opt: Bitmask of common optimizations to apply (BINREC_OPT_*).
 *     guest_opt: Bitmask of guest-specific optimizations to apply
 *         (BINREC_OPT_G_*).
 *     host_opt: Bitmask of host-specific optimizations to apply
 *         (BINREC_OPT_H_*).
 */
extern void binrec_set_optimization_flags(
    binrec_t *handle, unsigned int common_opt, unsigned int guest_opt,
    unsigned int host_opt);

/**
 * binrec_set_max_inline_length:  Set the maximum length (number of source
 * instructions, including the final return instruction) of subroutines to
 * inline.  The default is zero, meaning no subroutines will be inlined.
 *
 * If a nonzero length limit is set with this function, then when the
 * translator encounters a subroutine call instruction to a fixed address,
 * it will scan ahead up to this many instructions for a return
 * instruction.  If one is found, and if there are no branch instructions
 * that branch past the return, the subroutine will be inlined into the
 * current translation unit, saving the cost of jumping to a different
 * unit (which can be significant depending on how many guest registers
 * need to be spilled).
 *
 * If an inlined subroutine contains a further call instruction, that
 * subroutine will not be inlined regardless of its length.  (But see
 * binrec_set_max_inline_depth() to enable such recursive inlining.)
 *
 * Note that if a nonzero length limit is set, inlining may be performed
 * regardless of whether any optimization flags are set.
 *
 * [Parameters]
 *     handle: Handle to operate on.
 *     length: Maximum inline length (must be at least 0).
 */
extern void binrec_set_max_inline_length(binrec_t *handle, int length);

/**
 * binrec_set_max_inline_depth:  Set the maximum depth of subroutines to
 * inline.  The default is 1.
 *
 * If a depth limit greater than 1 is set with this function, then when a
 * call instruction is encountered during inlining, the translator will
 * perform the same inlining check on the called subroutine, up to the
 * specified depth.  For example, when translating at A in the following
 * pseudocode:
 *     A: call B
 *        ret
 *     B: call C
 *        ret
 *     C: call D
 *        ret
 *     D: call E
 *        ret
 *     E: nop
 *        ret
 * if the maximum inline depth is set to 2 (and assuming the maximum length
 * is set to at least 2), both B and C will be inlined, but D will not, and
 * the A routine will be translated as if it was written:
 *     A: call D
 *        ret
 *
 * Setting a value of zero disables inlining regardless of the maximum
 * inline length set with binrec_set_max_inline_length().
 *
 * [Parameters]
 *     handle: Handle to operate on.
 *     depth: Maximum inline depth (must be at least 0).
 */
extern void binrec_set_max_inline_depth(binrec_t *handle, int depth);

/**
 * binrec_add_readonly_region:  Mark the given region of memory as
 * read-only.  Instructions which are known to load from read-only memory
 * will be translated into load-constant operations if enabled by the
 * BINREC_OPT_FOLD_CONSTANTS optimization flag.
 *
 * When determining whether a load operation addresses read-only memory,
 * only the first (lowest) address of the referenced value is checked.
 * Thus, a multi-byte load operation which crosses the end of a read-only
 * region will still be translated to a load-constant operation, and any
 * subsequent changes to the bytes outside the read-only region will not
 * be seen by the translated code.
 *
 * If the guest code performs a store operation into a region marked as
 * read-only, subsequent behavior of the program is undefined.
 *
 * This function may fail if too many misaligned regions are added; in
 * that case, rebuild the library with different values of the
 * READONLY_PAGE_BITS and MAX_PARTIAL_READONLY constants in src/common.h.
 *
 * The address range specified by binrec_set_code_range() is treated as
 * read-only with respect to the instruction stream, regardless of whether
 * it is explicitly marked read-only via this function.  However, any data
 * interspersed within the instruction stream will only be treated as
 * constant data if the address of that data has been explicitly marked
 * read-only.
 *
 * [Parameters]
 *     handle: Handle to operate on.
 *     base: Base address (in guest memory) of read-only region.
 *     size: Size of read-only region, in bytes.
 * [Return value]
 *     True on success; false if the region could not be added because
 *     the partial-page table is full.
 */
extern int binrec_add_readonly_region(binrec_t *handle,
                                      uint32_t base, uint32_t size);

/**
 * binrec_clear_readonly_regions:  Clear all read-only memory regions
 * added with binrec_add_readonly_region().
 *
 * [Parameters]
 *     handle: Handle to operate on.
 */
extern void binrec_clear_readonly_regions(binrec_t *handle);

/**
 * binrec_enable_branch_callback:  Set whether to call a function (pointed
 * to by the value at the PSB offset given by state_offset_branch_callback)
 * immediately before a branch to another instruction within the same
 * translation unit.  If enabled, the callback is called immediately before
 * taking a branch within the translated code; if the called function
 * returns zero, the translated code will return to its caller rather than
 * continuing execution at the branch target.   This can be used to safely
 * interrupt execution of the guest code ("safely" in the sense of the PSB
 * being fully updated) at a finer granularity than an entire translation
 * unit.  The callback is not called for conditional branches which are not
 * taken or for branches which would return from the translated code in any
 * case (such as indirect branches).
 *
 * The callback receives two parameters: the processor state block pointer
 * passed to the translated code and the address of the branch instruction,
 * and returns an int indicating whether to continue execution (nonzero) or
 * return from the translated code (zero).
 *
 * Note that the state of the PSB is indeterminate when the callback is
 * called; each register field will have either the same value it had at
 * the start of the unit or some value which was subsequently stored to
 * that register, but in general, register fields will not contain current
 * register values.  As an exception, the instruction pointer field (nia
 * for PowerPC hosts) will always contain the target address of the branch.
 * If the callback function returns zero to terminate execution, the PSB
 * will be updated as usual on exit from the translated code.
 *
 * Calling this function has no effect on already-translated code.
 *
 * By default, the branch callback is disabled.
 *
 * [Parameters]
 *     handle: Handle to operate on.
 *     enable: True (nonzero) to enable the branch callback, false (zero)
 *         to disable it.
 */
extern void binrec_enable_branch_callback(binrec_t *handle, int enable);

/**
 * binrec_set_pre_insn_callback:  Set a callback function which will be
 * called immediately before executing each guest instruction.  This can
 * be used, for example, to log an execution trace or to record the state
 * of the guest processor at a particular point.  Pass NULL to disable an
 * existing callback.
 *
 * The callback receives two parameters: the processor state block pointer
 * passed to the translated code and the address of the instruction about
 * to be executed.
 *
 * Calling this function has no effect on already-translated code.
 *
 * The pre- and post-instruction callbacks are generally useful only for
 * debugging or analysis of code at runtime, so they are set directly as
 * pointers in the runtime environment under the assumption that the host
 * architecture is that of the runtime environment.  These callbacks should
 * not be enabled when cross-compiling to a different architecture.
 *
 * Enabling the pre- or post-instruction callback can have a significant
 * negative impact on performance.
 *
 * [Parameters]
 *     handle: Handle to operate on.
 *     callback: Callback to install, or NULL to clear any installed callback.
 */
extern void binrec_set_pre_insn_callback(binrec_t *handle,
                                         void (*callback)(void *, uint32_t));

/**
 * binrec_set_post_insn_callback:  Set a callback function which will be
 * called immediately after executing each guest instruction.  The state
 * of the guest processor will be the same as if translation had ended
 * immediately after the just-executed instruction.  Pass NULL to disable
 * an existing callback.
 *
 * The callback receives two parameters: the processor state block pointer
 * passed to the translated code and the address of the instruction that
 * was just executed.
 *
 * If both this callback and the branch callback are enabled, this callback
 * will be called before the branch callback for taken intra-unit branches.
 *
 * Calling this function has no effect on already-translated code.
 *
 * [Parameters]
 *     handle: Handle to operate on.
 *     callback: Callback to install, or NULL to clear any installed callback.
 */
extern void binrec_set_post_insn_callback(binrec_t *handle,
                                          void (*callback)(void *, uint32_t));

/*************************************************************************/
/********************** Interface: Code translation **********************/
/*************************************************************************/

/**
 * binrec_translate:  Translate a block of guest machine code into native
 * machine code.
 *
 * The "address" and "limit" parameters specify the inclusive address
 * bounds from which instructions will be read for this call.  Translation
 * will stop when the translator reaches a source instruction which is not
 * entirely contained in the inclusive range [address,limit],  or when all
 * code paths starting from "address" have been translated (such as when
 * the end of a function in the input program is reached).  A value of -1
 * for "limit" allows translation to continue until such a natural endpoint
 * is found.
 *
 * On success, the returned block can be executed by calling it as a
 * function with the following signature:
 *     void code(void *state);
 * where the single parameter is a pointer to a processor state block whose
 * structure conforms to the structure offsets specified in the setup data
 * passed to binrec_create_handle().
 *
 * The returned code pointer will have been allocated with the code_malloc
 * or code_realloc function passed in the setup structure to
 * binrec_create_handle(), or the relevant fallback function if code_*
 * functions were not supplied.
 *
 * Return-value arguments are only modified on a successful return.
 *
 * [Parameters]
 *     handle: Handle to use for translation.
 *     address: Address (in guest memory) of first instruction to translate.
 *     limit: Address (in guest memory) at which to terminate translation.
 *     code_ret: Pointer to variable to receive a pointer to the
 *         translated machine code.
 *     size_ret: Pointer to variable to receive the length of the
 *         translated machine code, in bytes.
 * [Return value]
 *     True (nonzero) on success, false (zero) on error.
 */
extern int binrec_translate(binrec_t *handle, uint32_t address, uint32_t limit,
                            void **code_ret, long *size_ret);

/*************************************************************************/
/*************************************************************************/

#ifdef __cplusplus
}  // extern "C"
#endif

#endif  // BINREC_H
