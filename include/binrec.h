/*
 * libbinrec: a recompiling translator for machine code
 * Copyright (c) 2016 Andrew Church <achurch@achurch.org>
 *
 * This software may be copied and redistributed under certain conditions;
 * see the file "COPYING" in the source code distribution for details.
 * NO WARRANTY is provided with this software.
 */

#ifndef BINREC_H
#define BINREC_H

#include <stddef.h>
#include <stdint.h>

#ifdef __cplusplus
extern "C" {
#endif

/*
 * General notes
 * =============
 *
 * In this header (and the library source code in general), "guest" refers
 * to the source CPU or architecture, i.e. the input to the translator, and
 * "host" or "native" refers to the target CPU or architecture, i.e. the
 * output of the translator.  A program which calls into code generated by
 * this library is referred to as a "client program".
 *
 * The numeric values of constants and the layout of structures in this
 * header are _not_ part of the public API; always use the symbolic names
 * rather than the numeric values or offsets when writing code which
 * interfaces to the library.  The library ABI (including those values and
 * offsets) will be kept consistent through revisions of a major version,
 * such that a program compiled against library version x.y (x >= 1) will
 * also run correctly using library version x.z (if z < y, features such
 * as optimization flags only defined later than version x.z may be
 * ignored, but the generated code will behave in a compatible manner).
 * However, the ABI may change between major versions, or at any time
 * before version 1.0.
 *
 *
 * Guest-specific notes
 * ====================
 *
 * The abbreviation "PSB" below refers to the processor state block, i.e.
 * the structure containing the current state of the guest processor.
 *
 * libbinrec is designed to allow a certain amount of flexibility in the
 * structure of the PSB.  The binrec_setup_t structure includes several
 * "state_offset_*" fields for specifying the byte offset of various
 * members of the PSB; the client program should set those fields to the
 * relevant offsets within its PSB structure.
 *
 * PowerPC 32-bit architectures (BINREC_ARCH_PPC_7XX)
 * --------------------------------------------------
 * Floating-point registers in the PSB are assumed to be stored as pairs
 * of 64-bit floating point ("double"-type) values, with the first value
 * of each pair holding the value of that register as a scalar or the ps0
 * slot of the register for paired-single mode, and the second value of
 * each pair holding the value of the ps1 slot for paired-single mode.
 * The translated code will take care of converting between single and
 * double precision as needed.  Note that the FPR array must be aligned to
 * a multiple of 16 bytes to avoid crashes due to misaligned accesses.
 *
 * Full floating-point exception handling bloats the translated code
 * significantly; in particular, paired-single arithmetic instructions
 * require several hundred host instructions each to correctly identify
 * all possible combinations of exception conditions, though most of
 * those instructions will be skipped for any particular execution of the
 * operation.  Client programs should enable as many of the floating-point
 * optimization flags as possible for best performance (even those marked
 * UNSAFE are in fact safe for the vast majority of real-world code).  If
 * necessary, specific optimizations can be safely disabled for individual
 * blocks of guest code; changing optimization flags for one translation
 * unit will have no effect on the behavior of any other translated code.
 *
 * The FEX and VX bits in FPSCR are not written to the copy of FPSCR
 * stored in the PSB, but are instead generated when needed by a
 * floating-point instruction with Rc=1 or the mffs or mcrfs instructions.
 * (This mimics the implementation of the bits on PowerPC CPUs: they have
 * no associated physical storage, and instead are hardwired to the
 * appropriate function of other FPSCR bits.)  Client code which needs to
 * check the state of FPSCR[FEX] or FPSCR[VX] should manually compute them
 * based on the relevant exception and mask bits.
 *
 * Translated code assumes that the host's floating-point rounding mode is
 * set based on FPSCR[RN] and all host floating-point exception flags are
 * clear on entry.  The code will maintain these invariants on all
 * outbound control transfers, so a client program which does not perform
 * any floating-point operations or modify FPSCR on its own only needs to
 * set host floating-point state once, before first calling translated code.
 *
 * The FPSCR[FR] bit is not set by any floating-point instructions, though
 * it can be written as usual by instructions which directly manipulate
 * FPSCR.
 *
 * The overflow and underflow exception enable bits (OE and UE) in FPSCR
 * are ignored; floating-point operations are performed as if both
 * exceptions are masked (FPSCR[OE]=0 and FPSCR[UE]=0).  However,
 * FPSCR[FEX] will still reflect the state of the OE and UE bits actually
 * stored in FPSCR, so (for example) an Rc=1 instruction that generates an
 * overflow exception with FPSCR[OE]=1 will set cr1.FEX to 1.
 *
 * The "non-IEEE" (NI) flag in FPSCR is ignored; floating-point operations
 * will always be performed in full precision.
 *
 * libbinrec implements the implementation-specific behavior of 32-bit
 * PowerPC processors (at least the 750CL) that single-precision
 * floating-point instructions accept double-precision operands, including
 * the quirk that a double-precision frC operand to a single-precision
 * multiply or multiply-add instruction is rounded to 24 bits (this latter
 * behavior can be suppressed with the BINREC_OPT_G_PPC_FAST_FMULS
 * optimization flag).
 *
 * The conditional load/store instructions (lwarx and stwcx.) rely on
 * hardware support for their behavior.  Since such hardware support is
 * not necessarily available in the host environment, and since a correct
 * implementation requires knowledge of that environment which is not
 * available to libbinrec, these instructions are implemented using a
 * compare-and-swap heuristic: an stwcx. after a lwarx succeeds if the
 * value at the target address is unchanged from the value it had when the
 * lwarx was executed.  Translated code for lwarx and stwcx makes use of
 * two PSB fields: reserve_flag (an 8-bit Boolean value), which records
 * whether an lwarx is pending, and reserve_state (a 32-bit integer value),
 * which stores the value loaded by the most recent lwarx.  This can result
 * in incorrect behavior if the guest code expects the store to fail due to
 * writes of an identical value or writes a new value using a regular store
 * between the conditional load and store, but this heuristic should
 * suffice for typical programs.  Note that the address of the lwarx is
 * _not_ saved; a stwcx. to a different address will still succeed if that
 * address contains the same value as was loaded by the lwarx instruction.
 * (This matches the behavior of actual PowerPC CPUs in the sense that
 * address mismatches between lwarx and stwcx. are ignored.)
 *
 * Access to the time base registers via the mftb instruction is
 * implemented by calling a host-side callback function, a pointer to
 * which should be stored in the PSB at the offset indicated by
 * state_offset_timebase_handler.  The signature of the function is
 * "uint64_t handler(PSB *)", taking the pointer to the PSB which was
 * passed to the translated code and returning the current 64-bit time
 * base value.  If the function pointer is NULL, reads of the time base
 * registers will always return zero.
 *
 * Exceptions generated by the system call (sc) and trap (tw/twi)
 * instructions are implemented as control transfers to host-side
 * functions, pointers to which should be stored in the PSB at the offsets
 * indicated by state_offset_sc_handler and state_offset_trap_handler
 * respectively.  The signature of the functions is "void handler(PSB *)",
 * taking the pointer to the PSB which was passed to the translated code.
 * The value of the NIA field in the PSB is set as the SRR0 register would
 * be set on a true PowerPC processor: to the address of the trap
 * instruction for trap exceptions, and to the address of the instruction
 * _following_ the sc instruction for system call exceptions (however, the
 * sequence "sc; blr" is optimized by setting NIA to the value of LR when
 * calling the system call handler).  The translated code will return
 * immediately to its caller when the handler returns.  The translated
 * code does not check for NULL function pointers, so it will crash if an
 * exception occurs and the associated function pointer is not set.
 *
 * All instruction words with the primary opcode of the sc instruction
 * (0x11) are decoded as that instruction.  This deviates from the PowerPC
 * specification, in which only the instruction 0x4400_0002 is a valid sc
 * instruction, but is done to allow the use of that instruction as (for
 * example) a callout to native code in a PowerPC system emulator in which
 * the specific function to call is encoded in the instruction word.  If
 * this behavior is not desired, the system call handler can simply treat
 * any instruction word other than 0x4400_0002 as an illegal instruction.
 *
 * If a D-form (immediate offset) load or store instruction has an offset
 * which causes the final address to wrap around the 32-bit address space,
 * such as lwz rD,16(rA) where the value of rA is 0xFFFFFFF0 or greater,
 * the access will improperly "leak" outside the guest memory region.
 * However, accesses to the top 32k of memory using single-register (not
 * lmw/stmw) D-form instructions with rA = 0 are handled correctly.
 *
 * Some obscure hardware quirks are not emulated by the translated code;
 * see the list of expected failures in tests/guest-ppc/exec/750cl-noopt.c
 * for details.
 *
 *
 * Host-specific notes
 * ===================
 *
 * Intel/AMD x86 64-bit architecture (BINREC_ARCH_X86_*)
 * -----------------------------------------------------
 * Translated code assumes support for all instruction set extensions
 * through SSE3.  (More specifically, the following CPUID feature bits are
 * assumed to be set: CMOV, SSE, SSE2, and SSE3.)  Use of later extensions
 * can be enabled by setting appropriate feature bits (BINREC_FEATURE_X86_*)
 * in the host_features field of binrec_setup_t.
 *
 * Translated code must be located at a 16-byte-aligned address for correct
 * behavior.  If the code is not correctly aligned, certain floating-point
 * operations may raise exceptions (specifically the general-protection
 * exception, "#GP" as described in Intel documentation).  libbinrec will
 * always request 16-byte alignment if a code_malloc() callback is supplied.
 *
 * Translated code maintains the host stack at 16-byte alignment, as
 * required by both System V and Windows ABIs.  If the client program calls
 * translated code with a misaligned stack, floating-point code may raise
 * exceptions due to unaligned stack accesses.
 *
 * Loads of 64-bit floating point ("double") 2-element vectors must be
 * 16-byte aligned, or an exception will be raised.  Other data types can
 * be loaded from any alignment, though values not aligned to a multiple of
 * the value size may take additional CPU cycles to load.
 *
 * Full (non-rounding) support for fused multiply-add operations is only
 * supported on CPUs which support the FMA3 instruction set.  On CPUs
 * without that extension, fused multiply-add operations will be translated
 * to separate multiply and add instructions, which will cause the
 * intermediate result to be rounded; this in turn may cause floating-point
 * exceptions to be incorrectly raised in certain edge cases (such as
 * HUGE_VAL * HUGE_VAL - inf, in which the multiplication rounds to
 * infinity and the resulting subtraction of infinities triggers an
 * exception).
 */

/*************************************************************************/
/*********************** Data types and constants ************************/
/*************************************************************************/

/*----------------------------- Basic types -----------------------------*/

/**
 * binrec_t:  Type of a translation handle.  This handle stores global
 * translation settings, such as optimization flags and functions to use
 * for memory allocation.
 */
typedef struct binrec_t binrec_t;

/**
 * binrec_arch_t:  Enumeration of architectures and variants supported by
 * the library.  All currently supported architectures are either
 * guest-only or host-only; see the inline comments at each enumerator.
 *
 * As a general rule, libbinrec assumes that its input is a program
 * designed to run on the selected guest architecture, and therefore all
 * instructions encountered in the program will be valid instruction
 * encodings.  Consequently, this enumeration only includes coarse
 * architecture families which encompass a group of compatible processors;
 * for example, the PPC_7XX architecture covers all PowerPC CPUs through
 * the 750CL, and the input program is assumed to use only instructions
 * which are valid on the architecture it was written for. See also the
 * note on library limitations in the README file.
 */
typedef enum binrec_arch_t {
    /* Constant used by binrec_native_arch() to indicate an unsupported
     * architecture. */
    BINREC_ARCH_INVALID = 0,

    /* PowerPC 32-bit architecture as implemented in PowerPC 7xx
     * processors, including all other instruction set extensions through
     * the PowerPC 750CL.  Also supports programs written for PowerPC 6xx
     * CPUs, with the exception of non-PowerPC instructions (such as ABS)
     * specific to the PowerPC 601. */
    BINREC_ARCH_PPC_7XX,                // Guest only.

    /* Intel/AMD x86 64-bit architecture, using the SysV ABI. */
    BINREC_ARCH_X86_64_SYSV,            // Host only.

    /* Intel/AMD x86 64-bit architecture, using the Windows ABI. */
    BINREC_ARCH_X86_64_WINDOWS,         // Host only.

    /* Variant of BINREC_ARCH_X86_64_WINDOWS which prepends unwind
     * information to the returned function.  The offset to the generated
     * code is stored as a 64-bit value at the returned code address, and
     * the unwind information is found immediately after that value. */
    BINREC_ARCH_X86_64_WINDOWS_SEH,     // Host only.
} binrec_arch_t;

/**
 * binrec_loglevel_t:  Enumeration of log levels which can be passed to
 * the log function specified in binrec_setup_t.
 */
typedef enum binrec_loglevel_t {
    BINREC_LOGLEVEL_INFO,    // Informational messages.
    BINREC_LOGLEVEL_WARNING, // Messages indicating a potential problem.
    BINREC_LOGLEVEL_ERROR,   // Messages indicating failure of some operation.
} binrec_loglevel_t;

/*--------------------- Architecture feature flags ----------------------*/

/*
 * These flags indicate the presence of specific features (such as optional
 * instructions) within a particular architecture.  These are used in the
 * "host_features" field of binrec_setup_t.
 */

/**
 * BINREC_FEATURE_X86_*:  Feature flags for the x86 architecture.
 */
#define BINREC_FEATURE_X86_FMA      (1U << 0)
#define BINREC_FEATURE_X86_MOVBE    (1U << 1)
#define BINREC_FEATURE_X86_POPCNT   (1U << 2)
#define BINREC_FEATURE_X86_AVX      (1U << 3)
#define BINREC_FEATURE_X86_LZCNT    (1U << 4)  // a.k.a. ABM
#define BINREC_FEATURE_X86_BMI1     (1U << 5)
#define BINREC_FEATURE_X86_AVX2     (1U << 6)
#define BINREC_FEATURE_X86_BMI2     (1U << 7)

/*--------------------------- Setup structure ---------------------------*/

/**
 * binrec_setup_t:  Structure which defines various parameters used by the
 * translator.  Used by binrec_create_handle().
 */
typedef struct binrec_setup_t {

    /**
     * guest, host:  BINREC_ARCH_* values indicating the architecture and
     * variant to translate from (guest) and to (host).  binrec_translate()
     * will fail if the library cannot perform the requested translation.
     */
    binrec_arch_t guest;
    binrec_arch_t host;

    /**
     * host_features:  Bitwise-OR of feature flags for the selected host
     * architecture, indicating which features should be assumed to be
     * present for host code generation.
     */
    unsigned int host_features;

    /**
     * guest_memory_base:  Pointer to a region of host memory reserved as
     * the address space of the guest code.  binrec_translate() calls will
     * read source machine instructions and constant data from this region.
     * Memory accesses within the translated code itself will use the
     * address passed as a parameter to the code.
     */
    void *guest_memory_base;

    /**
     * state_offset_*:  Offsets from the beginning of the processor state
     * block (as passed to the generated native code) to the various guest
     * registers and other processor state.  Each block of registers is
     * assumed to be contiguous; for example, GPR 1 is accessed by loading
     * a 32-bit value from state_offset_gpr + 4.  All multi-byte values are
     * assumed to be stored in host endian order.
     * FIXME: Generalize for non-PPC guests.
     */
    /* General-purpose registers (32 * uint32_t) */
    int state_offset_gpr;
    /* Floating-point registers (32 * double[2]) */
    int state_offset_fpr;
    /* Paired-single quantization registers (8 * uint32_t) */
    int state_offset_gqr;
    /* Miscellaneous registers (each uint32_t) */
    int state_offset_lr;
    int state_offset_ctr;
    int state_offset_cr;
    int state_offset_xer;
    int state_offset_fpscr;
    /* lwarx/stwcx. reservation flag (uint8_t) */
    int state_offset_reserve_flag;
    /* lwarx/stwcx. reservation state (uint32_t) */
    int state_offset_reserve_state;
    /* Next instruction address (updated on return from translated code) */
    int state_offset_nia;
    /* Pointer to function to handle time base reads.  Signature:
     * uint64_t timebase_handler(void *state) */
    int state_offset_timebase_handler;
    /* Pointer to function to handle system calls (sc instruction).
     * Signature: void sc_handler(void *state) */
    int state_offset_sc_handler;
    /* Pointer to function to handle trap exceptions.  Signature:
     * void trap_handler(void *state) */
    int state_offset_trap_handler;
    /* Pointer to function to call at intra-unit branches (see
     * binrec_enable_branch_callback()).  Signature:
     * int branch_callback(void *state, uint32_t branch_address) */
    int state_offset_branch_callback;
    /* Pointers to lookup tables (of type uint16_t[64]) for the fres and
     * frsqrte instructions.  See the BINREC_OPT_G_PPC_NATIVE_RECIPROCAL
     * optimization flag documentation for details. */
    int state_offset_fres_lut;
    int state_offset_frsqrte_lut;

    /**
     * userdata:  Opaque pointer which is passed to all callback functions
     * below.
     */
    void *userdata;

    /**
     * malloc:  Pointer to a function which allocates memory, like malloc().
     * If NULL, the system's malloc() will be used.
     *
     * Like standard malloc(), this function may return either NULL or a
     * pointer to a zero-size memory block if passed a size of zero.
     *
     * [Parameters]
     *     userdata: User data pointer from setup structure.
     *     size: Size of block to allocate, in bytes.
     * [Return value]
     *     Pointer to allocated memory, or NULL on error or if size == 0.
     */
    void *(*malloc)(void *userdata, size_t size);

    /**
     * realloc:  Pointer to a function which resizes a block of allocated
     * memory, like realloc().  If NULL, the system's realloc() will be used.
     *
     * Like standard realloc(), this function may return either NULL or a
     * pointer to a zero-size memory block if passed a size of zero.
     *
     * [Parameters]
     *     userdata: User data pointer from setup structure.
     *     ptr: Block to resize, or NULL to allocate a new block.
     *     size: New size of block, in bytes, or 0 to free the block.
     * [Return value]
     *     Pointer to allocated memory, or NULL on error or if size == 0.
     */
    void *(*realloc)(void *userdata, void *ptr, size_t size);

    /**
     * free:  Pointer to a function which frees a block of allocated
     * memory, like free().  If NULL, the system's free() will be used.
     *
     * [Parameters]
     *     userdata: User data pointer from setup structure.
     *     ptr: Block to free (may be NULL).
     * [Return value]
     *     Pointer to allocated memory, or NULL on error.
     */
    void (*free)(void *userdata, void *ptr);

    /**
     * code_malloc:  Pointer to a function which allocates a block of
     * memory for output machine code.  If NULL, the malloc() callback (or
     * the system's malloc(), if that callback is also NULL) will be used
     * and no alignment will be performed.
     *
     * [Parameters]
     *     userdata: User data pointer from setup structure.
     *     size: Size of block to allocate, in bytes (guaranteed to be
     *         nonzero).
     *     alignment: Desired address alignment, in bytes (guaranteed to
     *         be a power of 2).
     * [Return value]
     *     Pointer to allocated memory, or NULL on error.
     */
    void *(*code_malloc)(void *userdata, size_t size, size_t alignment);

    /**
     * code_realloc:  Pointer to a function which resizes a block of memory
     * allocated with the code_malloc() callback.  If NULL, the realloc()
     * callback (or the system's realloc(), if that callback is also NULL)
     * will be used.
     *
     * [Parameters]
     *     userdata: User data pointer from setup structure.
     *     ptr: Block to resize (guaranteed to be non-NULL).
     *     old_size: Current size of block, in bytes.
     *     new_size: New size of block, in bytes (guaranteed to be nonzero).
     *     alignment: Required address alignment, in bytes (guaranteed to
     *         be equal to the value used for initial allocation).
     * [Return value]
     *     Pointer to allocated memory, or NULL on error.
     */
    void *(*code_realloc)(void *userdata, void *ptr, size_t old_size,
                          size_t new_size, size_t alignment);

    /**
     * code_free:  Pointer to a function which frees a block of memory
     * allocated with the code_malloc() callback.  If NULL, the free()
     * callback (or the system's free(), if that callback is also NULL)
     * will be used.
     *
     * [Parameters]
     *     userdata: User data pointer from setup structure.
     *     ptr: Block to free (may be NULL).
     */
    void (*code_free)(void *userdata, void *ptr);

    /**
     * log:  Pointer to a function to log messages from the library.
     * If NULL, no logging will be performed.
     *
     * [Parameters]
     *     userdata: User data pointer from setup structure.
     *     level: Log level (BINREC_LOGLEVEL_*).
     *     message: Log message.
     */
    void (*log)(void *userdata, binrec_loglevel_t level, const char *message);

} binrec_setup_t;

/*--------------------- General optimization flags ----------------------*/

/*
 * Optimizations performed by the library can generally be classified into
 * three types:
 *
 * - Behavior-safe: optimizations which purely affect the size or speed of
 *   the generated code and have no effect on behavior.  Optimizations
 *   such as constant folding and deconditioning fall into this category.
 *   Optimizations can be assumed to fall under this category where not
 *   otherwise documented.
 *
 * - Specification-safe: optimizations which may change the behavior of
 *   the generated code, but only within limits prescribed by the relevant
 *   specification.  For example, the NATIVE_IEEE_UNDERFLOW optimization
 *   may change the results of certain floating-point operations relative
 *   to the results returned by guest code running on its native hardware,
 *   but the IEEE floating-point specification allows either of two
 *   behaviors, so with respect to that specification, the optimized code
 *   is no less correct than the original.  As long as the guest code was
 *   written to follow the specifications rather than the precise behavior
 *   of the guest hardware, it will still behave correctly under these
 *   optimizations.
 *
 * - Unsafe: optimizations which can materially impact the behavior of the
 *   generated code, such as stack frame optimization.  These optimizations
 *   can benefit code which rigorously adhere to the relevant assumptions,
 *   such as code produced by a high-level language compiler, but they can
 *   cause nonconformant code to misbehave or even crash.  Documentation
 *   for an unsafe optimization will clearly indicate that fact.
 */

/**
 * BINREC_OPT_BASIC:  Enable basic optimization of translated code.  This
 * includes the following transformations:
 *
 * - Branches to other (unconditional or same-conditioned) branch
 *   instructions will be threaded through to the final branch destination.
 *
 * - Unreachable basic blocks will be eliminated from the code stream.
 *
 * - Branches to the next instruction will be eliminated.
 */
#define BINREC_OPT_BASIC  (1<<0)

/**
 * BINREC_OPT_DECONDITION:  Convert conditional branches and moves with
 * constant conditions to unconditional instructions or NOPs.  This is
 * most useful in conjunction with constant folding.
 */
#define BINREC_OPT_DECONDITION  (1<<1)

/**
 * BINREC_OPT_DEEP_DATA_FLOW:  Perform extended data flow analysis on
 * values associated with guest architecture registers to find dead stores.
 * This optimization by itself only finds dead stores; enable BINREC_OPT_DSE
 * to remove them from the code stream.
 */
#define BINREC_OPT_DEEP_DATA_FLOW  (1<<2)

/**
 * BINREC_OPT_DSE:  Perform dead store elimination (DSE) on the translated
 * code, removing instructions whose outputs are not used.
 *
 * Instructions with side effects, such as floating-point operations (which
 * could raise exceptions) or atomic read-modify-write instructions, are
 * not eliminated.  However, floating-point instructions will be eliminated
 * if the BINREC_OPT_DSE_FP optimization is also enabled.
 */
#define BINREC_OPT_DSE  (1<<3)

/**
 * BINREC_OPT_DSE_FP:  Allow elimination of floating-point operations when
 * performing dead store elimination.
 *
 * This optimization is UNSAFE: if an eliminated operation would have
 * raised a floating-point exception which the guest code checks for, the
 * translated code will not behave correctly.
 */
#define BINREC_OPT_DSE_FP  (1<<4)

/**
 * BINREC_OPT_FOLD_CONSTANTS:  Look for computations whose operands are all
 * constant and load operations which load from a constant address within
 * memory marked read-only (see binrec_add_readonly_region()), and convert
 * them to load-immediate operations.  The computed values are themselves
 * treated as constant, so constantness can be propagated through multiple
 * instructions.  Intermediate values in a computation sequence which end
 * up being unused due to constant folding, as well as any other
 * instructions whose outputs which are not used elsewhere, are removed
 * from the code stream if BINREC_OPT_DSE is also enabled.
 *
 * Floating-point operations will not be folded unless the
 * BINREC_OPT_FOLD_FP_CONSTANTS optimization is also enabled.
 */
#define BINREC_OPT_FOLD_CONSTANTS  (1<<5)

/**
 * BINREC_OPT_FOLD_FP_CONSTANTS:  Fold floating-point as well as integer
 * constants, performing the floating-point operations in the runtime
 * environment.  Any floating-point exceptions generated by the operation
 * are discarded.
 *
 * This flag is ignored if BINREC_OPT_FOLD_CONSTANTS is not also enabled.
 *
 * This optimization is UNSAFE: if the floating-point behavior of the
 * runtime environment differs materially from that of the guest
 * architecture (such as by not complying with IEEE 754) or if a folded
 * operation generates a floating-point exception and the guest code
 * expects to detect that exception, the translated code will not behave
 * correctly.
 */
#define BINREC_OPT_FOLD_FP_CONSTANTS  (1<<6)

/**
 * BINREC_OPT_NATIVE_IEEE_NAN:  Use the host's rules for NaN results of
 * floating-point operations, even when those rules differ from the guest
 * architecture.
 *
 * The IEEE specification allows differing behavior between implementations
 * in the following cases:
 *
 * - If more than one operand to an operation is a NaN, the returned NaN
 *   may be any of those values.
 *
 * - If a NaN is generated due to an invalid operation, its bit pattern
 *   may be any quiet NaN bit pattern.
 *
 * This optimization allows the translator to translate floating-point
 * operations directly to their host equivalents without manually checking
 * for NaNs, which can require several additional host instructions per
 * guest instruction.
 *
 * This optimization is specification-safe: as long as guest code follows
 * the IEEE 754 specifications, it will behave correctly under this
 * optimization.
 */
#define BINREC_OPT_NATIVE_IEEE_NAN  (1<<7)

/**
 * BINREC_OPT_NATIVE_IEEE_UNDERFLOW:  Use the host's definition of
 * underflow for IEEE floating-point arithmetic, even when that differs
 * from the guest definition.
 *
 * When translating between architectures which use different definitions
 * of underflow (IEEE allows two different behaviors: tiny before rounding
 * and tiny after rounding), this optimization allows floating-point
 * operations to be translated directly to their equivalent host
 * instructions, at the cost of different exception states for operations
 * with a result which is treated as underflowing on one architecture and
 * not the other.  If this optimization is disabled, floating-point
 * operations must check explicitly for underflow, which can require
 * several additional host instructions per guest instruction.
 *
 * If the host and guest use the same "tiny" rules, floating-point
 * operations can always be translated directly to native instructions
 * (at least with regard to tininess), and this flag has no effect on
 * translation.
 *
 * Enabling the BINREC_OPT_DSE and BINREC_OPT_DSE_FP optimizations will
 * typically have the effect of enabling this optimization as well.
 *
 * This optimization is specification-safe: as long as guest code follows
 * the IEEE 754 specifications, it will behave correctly under this
 * optimization.
 */
#define BINREC_OPT_NATIVE_IEEE_UNDERFLOW  (1<<8)

/*----------- Guest-architecture-specific optimization flags ------------*/

/**
 * BINREC_OPT_G_PPC_ASSUME_NO_SNAN:  Do not attempt to preserve the
 * signaling/quiet state of floating-point NaN (not-a-number) values.
 *
 * The single-precision lfs and stfs instructions preserve the state of the
 * "quiet" bit in a floating-point NaN (the high bit of the mantissa) when
 * converting it to or from double precision, but the host instructions
 * used to implement such a format conversion may treat it as an arithmetic
 * operation which quiets any incoming signaling NaN, and detecting that
 * such a change took place can require many more host instructions than
 * the conversion itself.  If this optimization is enabled, the translator
 * will use the fastest possible method to convert between single and
 * double precision, ignoring the possibility of signaling NaNs.  If a
 * signaling NaN is in fact loaded, it may cause a later floating-point
 * instruction to incorrectly detect an invalid-operation exception and
 * return an incorrect value.
 *
 * As a side effect, this optimization also modifies emulation of the
 * undocumented hardware quirk that single-precision floating-point
 * instructions accept double-precision arguments.  When this optimization
 * is enabled, if an operand to a single-precision instruction (except stfs
 * and related instructions, and including 750CL-specific paired-single
 * instructions) is not representable in single precision, the instruction
 * may raise a floating-point overflow, underflow, or inexact exception
 * which is improperly detected by a later floating-point instruction.
 * Note that the use of double-precision operands (i.e., operands which
 * cannot be represented in single precision) with single-precision
 * instructions is documented in the PowerPC specification to store
 * undefined data in the output register and FPSCR.
 *
 * This optimization is UNSAFE: code which relies on being able to load a
 * signaling NaN will not behave correctly.
 */
#define BINREC_OPT_G_PPC_ASSUME_NO_SNAN  (1<<0)

/**
 * BINREC_OPT_G_PPC_CONSTANT_GQRS:  Assume that the values of the GQRs
 * (graphics quantization registers, used with paired-single load and
 * store instructions) are constant with respect to the entry point of a
 * translation unit.
 *
 * Ordinarily, translated code for a psq_l* or psq_st* instruction must
 * read the referenced GQR at runtime and choose the appropriate load or
 * store operation, which both adds several instructions' worth of latency
 * and significantly increases code size.  If this optimization is enabled,
 * the translator will instead read (at translation time) the value of each
 * GQR referenced by guest code and translate paired-single load and store
 * instructions based on those values.
 *
 * If this optimization is enabled, an mtspr instruction which writes to a
 * GQR will cause the translated code to immediately return to its caller.
 * This ensures that any following load or store instructions will be
 * translated using the value written by the mtspr instruction.
 *
 * This optimization is UNSAFE: if the value of a GQR is not constant with
 * respect to any paired-single load or store instruction, the translated
 * code will not behave correctly.
 */
#define BINREC_OPT_G_PPC_CONSTANT_GQRS  (1<<1)

/**
 * BINREC_OPT_G_PPC_FAST_FMULS:  Do not attempt to round the second
 * multiplicand (frC) to a single-precision multiply or multiply-add
 * instruction.
 *
 * According to the PowerPC architecture specification, the result of
 * using non-single-precision values with single-precision instructions is
 * undefined.  Real 32-bit PowerPC chips (at least the 750CL) just perform
 * the operation in double precision and round the result to single
 * precision -- with one exception: the second operand (frC) to a multiply
 * operation has its mantissa rounded to 24 bits before the multiplication
 * is performed.  libbinrec implements this rounding on an frC operand
 * which is not known to already be in single-precision format; since the
 * library does not perform the deep analysis required to carry knowledge
 * of data format across branches (such as in loops), rounding may have to
 * be performed frequently even in guest code which properly converts all
 * values to single precision before using single-precision insturctions.
 * This rounding is fairly expensive because of the various edge cases
 * that need to be handled.
 *
 * If this optimization is enabled, libbinrec will assume that the frC
 * operand to an fmuls, fmadds, fmsubs, fnmadds, or fnmsubs instruction is
 * representable in single precision even if it is not known to be in
 * single-precision format, and will skip the rounding step.
 *
 * In the more general case of double-precision operands used with
 * single-precision instructions, libbinrec always performs the operation
 * in double precision, since it will generally be no slower (and often
 * faster) to round the result after the operation than to round all input
 * operands beforehand, and as long as the input values are representable
 * in single precision, rounding a double-precision result gives the same
 * output as performing the operation in single precision.
 *
 * This optimization is specification-safe: as long as guest code follows
 * the PowerPC architecture specification, it will behave correctly under
 * this optimization.
 */
#define BINREC_OPT_G_PPC_FAST_FMULS  (1<<2)

/**
 * BINREC_OPT_G_PPC_FNMADD_ZERO_SIGN:  Do not attempt to return the correct
 * sign on the result of an fnmadd[s] or fnmsub[s] instruction.
 *
 * The PowerPC fnmadd and fnmsub instructions calculate -(frA*frC+frB) and
 * -(frA*frC-frB), respectively.  These differ from the fused multiply-add
 * instructions some other architectures, such as x86, in which the
 * operations of the same names only negate the product, such that fnmadd
 * calculates -(frA*frC)+frB.  While this difference can be mostly covered
 * by translating to the opposite operation (PowerPC fnmadd -> x86 fnmsub),
 * this gives the wrong sign on some zero results, so a correct translation
 * requires using a positive fmadd/fmsub and manually negating the result.
 *
 * Enabling this optimization allows the translator to translate these
 * instructions to single fnmsub/fnmadd operations, at the cost of
 * returning zero with an incorrect sign in the cases mentioned above.
 *
 * This optimization is UNSAFE for obvious reasons, though it is believed
 * that most real-life PowerPC code does not differentiate between positive
 * and negative zero.
 */
#define BINREC_OPT_G_PPC_FNMADD_ZERO_SIGN  (1<<3)

/**
 * BINREC_OPT_G_PPC_IGNORE_FPSCR_VXFOO:  Do not set FPSCR exception bits
 * for specific invalid exception types (the "VXFOO" bits).
 *
 * The PowerPC architecture includes several FPSCR bits which indicate
 * specific types of floating-point invalid operation exceptions, such as
 * subtraction of infinities (VXISI) or use of a signaling NaN (VXSNAN).
 * Detecting these cases on a host architecture which does not expose such
 * information requires additional manual checks on the operands to each
 * floating-point operation and can have a severe impact on performance.
 * Enabling this optimization allows the translator to skip these checks,
 * treating any invalid-operation exception as VXSNAN whether or not any
 * operand was in fact a signaling NaN.  (Other VXFOO exception bits are
 * still set in cases where doing so does not affect performance.)
 *
 * Instructions which directly manipulate FPSCR, such as mtfsf, are not
 * affected by this optimization and continue to behave normally.
 *
 * This optimization is UNSAFE for obvious reasons, though it is believed
 * that most real-life PowerPC code does not make use of the VXFOO bits.
 *
 * This optimization has no effect if BINREC_OPT_G_PPC_NO_FPSCR_STATE is
 * enabled.
 */
#define BINREC_OPT_G_PPC_IGNORE_FPSCR_VXFOO  (1<<4)

/**
 * BINREC_OPT_G_PPC_NATIVE_RECIPROCAL:  Translate guest PowerPC
 * reciprocal-estimate instructions (fres and frsqrte) directly to their
 * host equivalents, maintaining compliance with the PowerPC architecture
 * specification but disregarding the precise behavior of the guest
 * architecture.
 *
 * The PowerPC architecture specifies bounds within which the results of
 * these instructions will fall relative to the true (mathematical) result.
 * Programs written to be compliant with the architecture will work
 * correctly regardless of the exact output of the instruction, though the
 * precise behavior of the program (for example, the low-end bits of the
 * result) may change.  This flag allows the translator to choose faster
 * host instructions which may not give exactly the same result but still
 * satisfy the PowerPC architecture constraints.
 *
 * If this optimization is disabled, the translator will attempt to match
 * the precise behavior of the guest architecture by using lookup tables
 * referenced by pointers in the processor state block (see the
 * state_offset_fres_lut and state_offset_frsqrte_lut fields in
 * binrec_setup_t).  The translated code will crash if it executes an fres
 * or frsqrte instruction, this optimization is not enabled, and the
 * appropriate pointer in the state block is not set.
 *
 * The tables for the 750CL processor are as follows:
 *
 * fres: 0x3FFC,0x3E1, 0x3C1C,0x3A7, 0x3875,0x371, 0x3504,0x340,
 *       0x31C4,0x313, 0x2EB1,0x2EA, 0x2BC8,0x2C4, 0x2904,0x2A0,
 *       0x2664,0x27F, 0x23E5,0x261, 0x2184,0x245, 0x1F40,0x22A,
 *       0x1D16,0x212, 0x1B04,0x1FB, 0x190A,0x1E5, 0x1725,0x1D1,
 *       0x1554,0x1BE, 0x1396,0x1AC, 0x11EB,0x19B, 0x104F,0x18B,
 *       0x0EC4,0x17C, 0x0D48,0x16E, 0x0BD7,0x15B, 0x0A7C,0x15B,
 *       0x0922,0x143, 0x07DF,0x143, 0x069C,0x12D, 0x056F,0x12D,
 *       0x0442,0x11A, 0x0328,0x11A, 0x020E,0x108, 0x0106,0x106
 *
 * frsqrte: 0x7FF4,0x7A4, 0x7852,0x700, 0x7154,0x670, 0x6AE4,0x5F2,
 *          0x64F2,0x584, 0x5F6E,0x524, 0x5A4C,0x4CC, 0x5580,0x47E,
 *          0x5102,0x43A, 0x4CCA,0x3FA, 0x48D0,0x3C2, 0x450E,0x38E,
 *          0x4182,0x35E, 0x3E24,0x332, 0x3AF2,0x30A, 0x37E8,0x2E6,
 *          0x34FD,0x568, 0x2F97,0x4F3, 0x2AA5,0x48D, 0x2618,0x435,
 *          0x21E4,0x3E7, 0x1DFE,0x3A2, 0x1A5C,0x365, 0x16F8,0x32E,
 *          0x13CA,0x2FC, 0x10CE,0x2D0, 0x0DFE,0x2A8, 0x0B57,0x283,
 *          0x08D4,0x261, 0x0673,0x243, 0x0431,0x226, 0x020B,0x20B
 *
 * Depending on the performance details of the host CPU and the types of
 * input values used by the guest code, enabling this optimization may
 * actually result in slower code (particularly for frsqrte), though it
 * will always reduce code size.
 *
 * This optimization is specification-safe: as long as guest code follows
 * the PowerPC architecture specification, it will behave correctly under
 * this optimization.
 */
#define BINREC_OPT_G_PPC_NATIVE_RECIPROCAL  (1<<5)

/**
 * BINREC_OPT_G_PPC_NO_FPSCR_STATE:  Do not write any state bits (exception
 * bits, FR, FI, or FPRF) in FPSCR based on floating-point operation results.
 *
 * Enabling this optimization causes the translated code to ignore all
 * host FPU exception conditions and skip setting FPRF to reflect the
 * value type.  For guest code which does not check the FPSCR status bits,
 * this results in significantly faster and smaller translated code with
 * no effect on program behavior.
 *
 * The control mode bits are honored as usual, though only FPSCR[RN] has
 * any effect on program behavior in this case; the exception enable bits
 * are meaningless since exceptions are not detected, and nonzero FPSCR[NI]
 * is not currently supported by the translator.
 *
 * Instructions which directly manipulate FPSCR, such as mtfsf, are not
 * affected by this optimization and continue to behave normally, though
 * if any of the FR/FI/FPRF bits are set by such an instruction, they
 * will remain set even after floating-point instructions which would
 * normally overwrite them.
 *
 * Floating-point instructions with the Rc bit set will copy the high 4
 * bits of FPSCR to the cr1 field of CR as usual, though the bit values
 * will naturally not reflect the result of any floating-point operations.
 * The library will log a warning (once per translation unit) if such an
 * instruction is encountered when this optimization is enabled.
 *
 * This optimization implicitly enables BINREC_OPT_NATIVE_IEEE_UNDERFLOW.
 *
 * This optimization is UNSAFE: code which relies on any of the FPSCR
 * state bits will behave incorrectly if this optimization is enabled.
 */
#define BINREC_OPT_G_PPC_NO_FPSCR_STATE  (1<<6)

/**
 * BINREC_OPT_G_PPC_PS_STORE_DENORMALS:  Do not flush denormals to zero
 * when storing floating-point values with the paired-single store
 * instructions (psq_st[u][x]).
 *
 * Normally, the paired-single store instructions flush denormal values
 * to zero before writing them to memory.  Enabling this optimization
 * allows the translator to skip the expensive denormal check and write
 * the values straight to memory.
 *
 * This optimization is UNSAFE: code which relies on denormals being
 * flushed to zero by paired-single store instructions will behave
 * incorrectly if this optimization is enabled.
 */
#define BINREC_OPT_G_PPC_PS_STORE_DENORMALS  (1<<7)

/**
 * BINREC_OPT_G_PPC_TRIM_CR_STORES:  Analyze the data flow through each
 * CR bit and eliminate stores which are not visible outside the
 * translated code.
 *
 * If this optimization is enabled, pre- and post-instruction callbacks,
 * branch callbacks, and timebase handlers may see incorrect values of CR
 * in the processor state block.  System call and trap handlers are not
 * affected.
 */
#define BINREC_OPT_G_PPC_TRIM_CR_STORES  (1<<8)

/*------------ Host-architecture-specific optimization flags ------------*/

/**
 * BINREC_OPT_H_X86_ADDRESS_OPERANDS:  Encode certain address calculations
 * directly in a load, store, or atomic instruction when feasible.  If the
 * address operand of such an instruction is not referenced by any other
 * instruction (after the one that sets it), then:
 *
 * - If the address is the sum of a register and a constant, and the sum of
 *   that constant and the offset encoded in the instruction is within the
 *   range of a 32-bit signed integer, eliminate the addition and use the
 *   combined offset as the access offset in the instruction.
 *
 * - If the address is the sum of two registers, eliminate the addition and
 *   encode the access using the base-plus-index format.
 */
#define BINREC_OPT_H_X86_ADDRESS_OPERANDS  (1<<0)

/**
 * BINREC_OPT_H_X86_BRANCH_ALIGNMENT:  Align branch targets to a multiple
 * of 16 bytes by inserting NOP instructions at appropriate points in the
 * generated code stream.
 */
#define BINREC_OPT_H_X86_BRANCH_ALIGNMENT  (1<<1)

/**
 * BINREC_OPT_H_X86_CONDITION_CODES:  Track the state of the condition
 * codes in the EFLAGS register, and avoid adding an explicit TEST or CMP
 * instruction for a register if the condition codes already reflect the
 * value of that register.
 */
#define BINREC_OPT_H_X86_CONDITION_CODES  (1<<2)

/**
 * BINREC_OPT_H_X86_FIXED_REGS:  When an instruction requires an operand to
 * be in a specific hardware register (shift counts must be in CL, for
 * example), try harder to allocate that hardware register for the operand.
 * This requires an extra pass over the translated machine code during
 * register allocation.
 */
#define BINREC_OPT_H_X86_FIXED_REGS  (1<<3)

/**
 * BINREC_OPT_H_X86_FORWARD_CONDITIONS:  When a register used as the
 * condition for a conditional branch or move is the result of a comparison
 * instruction and that register is not used elsewhere, eliminate the
 * register and forward the comparison condition to the branch or move
 * instruction.
 *
 * Floating-point comparisons will not be eliminated unless the
 * BINREC_OPT_DSE_FP common optimization flag is enabled.
 */
#define BINREC_OPT_H_X86_FORWARD_CONDITIONS  (1<<4)

/**
 * BINREC_OPT_H_X86_MERGE_REGS:  Try harder to avoid moving values
 * between registers.
 */
#define BINREC_OPT_H_X86_MERGE_REGS  (1<<5)

/**
 * BINREC_OPT_H_X86_STORE_IMMEDIATE:  When an immediate value is used only
 * as the data for a store operation, encode the immediate value directly
 * in the instruction instead of using a register.
 */
#define BINREC_OPT_H_X86_STORE_IMMEDIATE  (1<<6)

/*************************************************************************/
/******** Interface: Library and runtime environment information *********/
/*************************************************************************/

/**
 * binrec_version:  Return the version number of the library as a string
 * (for example, "1.2.3").
 *
 * [Return value]
 *     Library version number.
 */
extern const char *binrec_version(void);

/**
 * binrec_native_arch:  Return a BINREC_ARCH_* constant representing the
 * architecture of the runtime environment, or 0 (BINREC_ARCH_INVALID) if
 * the runtime environment does not correspond to a supported host
 * architecture.  (If a nonzero value is returned, it will always be valid
 * as a host architecture for translation.)
 *
 * [Return value]
 *     Runtime environment architecture (BINREC_ARCH_*), or 0 if unsupported.
 */
extern binrec_arch_t binrec_native_arch(void);

/**
 * binrec_native_features:  Return a bitmask of architecture features
 * (BINREC_FEATURE_*) supported by the runtime environment, or 0 if the
 * runtime environment does not correspond to a supported architecture.
 *
 * [Return value]
 *     Runtime environment feature bitmap, or 0 if unsupported.
 */
extern unsigned int binrec_native_features(void);

/**
 * binrec_guest_supported:  Return whether the given architecture is
 * supported as a guest architecture for translation.
 *
 * [Parameters]
 *     arch: Architecture to check.
 * [Return value]
 *     True (nonzero) if the given architecture is supported as a guest
 *     architecture, false (zero) if not.
 */
extern int binrec_guest_supported(binrec_arch_t arch);

/**
 * binrec_host_supported:  Return whether the given architecture is
 * supported as a guest architecture for translation.
 *
 * [Parameters]
 *     arch: Architecture to check.
 * [Return value]
 *     True (nonzero) if the given architecture is supported as a guest
 *     architecture, false (zero) if not.
 */
extern int binrec_host_supported(binrec_arch_t arch);

/*************************************************************************/
/*************** Interface: Translation handle management ****************/
/*************************************************************************/

/**
 * binrec_create_handle:  Create a new translation handle.
 *
 * [Parameters]
 *     setup: Pointer to a binrec_setup_t structure that defines the
 *         translation parameters to use.
 * [Return value]
 *     Newly created handle, or NULL on error.
 */
extern binrec_t *binrec_create_handle(const binrec_setup_t *setup);

/**
 * binrec_destroy_handle:  Destroy a translation handle.
 *
 * This function only destroys the translation handle itself; blocks of
 * translated code generated through the handle remain valid even after
 * the handle is destroyed.
 *
 * [Parameters]
 *     handle: Handle to destroy (may be NULL).
 */
extern void binrec_destroy_handle(binrec_t *handle);

/**
 * binrec_set_code_range:  Set the minimum and maximum addresses from which
 * to read source machine instructions.  Branch instructions which attempt
 * to jump outside this range will terminate the translation unit, and if
 * the source machine code runs off the end of the range, the unit will be
 * terminated at the final instruction completely contained within the range.
 * The range must not wrap around the end of the address space.
 *
 * By default, the entire address space is considered valid for reading
 * instructions.
 *
 * Note that binrec_translate() also allows specifying an address range for
 * translation.  This function is intended more for the purpose of avoiding
 * translation of memory areas known to be outside the bounds of the input
 * program code, such as data segments or undefined memory, similar to the
 * "execute" permission bit in hardware memory management units.  (It is
 * not currently possible to specify multiple disjoint code ranges.)
 *
 * [Parameters]
 *     handle: Handle to operate on.
 *     start: First address of code range.
 *     end: Last address of code range (inclusive).
 */
extern void binrec_set_code_range(binrec_t *handle, uint32_t start,
                                  uint32_t end);

/**
 * binrec_set_optimization_flags:  Set which optimizations should be
 * performed on translated blocks.  Enabling more optimizations will
 * improve the performance of translated code but increase the overhead
 * of translation; see the documentation on each optimization flag for
 * details.
 *
 * The set of enabled optimizations may be changed at any time without
 * impacting the behavior of already-translated blocks.
 *
 * By default, no optimizations are enabled.
 *
 * [Parameters]
 *     handle: Handle to operate on.
 *     common_opt: Bitmask of common optimizations to apply (BINREC_OPT_*).
 *     guest_opt: Bitmask of guest-specific optimizations to apply
 *         (BINREC_OPT_G_*).
 *     host_opt: Bitmask of host-specific optimizations to apply
 *         (BINREC_OPT_H_*).
 */
extern void binrec_set_optimization_flags(
    binrec_t *handle, unsigned int common_opt, unsigned int guest_opt,
    unsigned int host_opt);

/**
 * binrec_set_max_inline_length:  Set the maximum length (number of source
 * instructions, including the final return instruction) of subroutines to
 * inline.  The default is zero, meaning no subroutines will be inlined.
 *
 * If a nonzero length limit is set with this function, then when the
 * translator encounters a subroutine call instruction to a fixed address,
 * it will scan ahead up to this many instructions for a return
 * instruction.  If one is found, and if there are no branch instructions
 * that branch past the return, the subroutine will be inlined into the
 * current translation unit, saving the cost of jumping to a different
 * unit (which can be significant depending on how many guest registers
 * need to be spilled).
 *
 * If an inlined subroutine contains a further call instruction, that
 * subroutine will not be inlined regardless of its length.  (But see
 * binrec_set_max_inline_depth() to enable such recursive inlining.)
 *
 * Note that if a nonzero length limit is set, inlining may be performed
 * regardless of whether any optimization flags are set.
 *
 * [Parameters]
 *     handle: Handle to operate on.
 *     length: Maximum inline length (must be at least 0).
 */
extern void binrec_set_max_inline_length(binrec_t *handle, int length);

/**
 * binrec_set_max_inline_depth:  Set the maximum depth of subroutines to
 * inline.  The default is 1.
 *
 * If a depth limit greater than 1 is set with this function, then when a
 * call instruction is encountered during inlining, the translator will
 * perform the same inlining check on the called subroutine, up to the
 * specified depth.  For example, when translating at A in the following
 * pseudocode:
 *     A: call B
 *        ret
 *     B: call C
 *        ret
 *     C: call D
 *        ret
 *     D: call E
 *        ret
 *     E: nop
 *        ret
 * if the maximum inline depth is set to 2 (and assuming the maximum length
 * is set to at least 2), both B and C will be inlined, but D will not, and
 * the A routine will be translated as if it was written:
 *     A: call D
 *        ret
 *
 * Setting a value of zero disables inlining regardless of the maximum
 * inline length set with binrec_set_max_inline_length().
 *
 * [Parameters]
 *     handle: Handle to operate on.
 *     depth: Maximum inline depth (must be at least 0).
 */
extern void binrec_set_max_inline_depth(binrec_t *handle, int depth);

/**
 * binrec_add_readonly_region:  Mark the given region of memory as
 * read-only.  Instructions which are known to load from read-only memory
 * will be translated into load-constant operations if enabled by the
 * BINREC_OPT_FOLD_CONSTANTS optimization flag.
 *
 * When determining whether a load operation addresses read-only memory,
 * only the first (lowest) address of the referenced value is checked.
 * Thus, a multi-byte load operation which crosses the end of a read-only
 * region will still be translated to a load-constant operation, and any
 * subsequent changes to the bytes outside the read-only region will not
 * be seen by the translated code.
 *
 * If the guest code performs a store operation into a region marked as
 * read-only, subsequent behavior of the program is undefined.
 *
 * This function may fail if too many misaligned regions are added; in
 * that case, rebuild the library with different values of the
 * READONLY_PAGE_BITS and MAX_PARTIAL_READONLY constants in src/common.h.
 *
 * The address range specified by binrec_set_code_range() is treated as
 * read-only with respect to the instruction stream, regardless of whether
 * it is explicitly marked read-only via this function.  However, any data
 * interspersed within the instruction stream will only be treated as
 * constant data if the address of that data has been explicitly marked
 * read-only.
 *
 * [Parameters]
 *     handle: Handle to operate on.
 *     base: Base address (in guest memory) of read-only region.
 *     size: Size of read-only region, in bytes.
 * [Return value]
 *     True on success; false if the region could not be added because
 *     the partial-page table is full.
 */
extern int binrec_add_readonly_region(binrec_t *handle,
                                      uint32_t base, uint32_t size);

/**
 * binrec_clear_readonly_regions:  Clear all read-only memory regions
 * added with binrec_add_readonly_region().
 *
 * [Parameters]
 *     handle: Handle to operate on.
 */
extern void binrec_clear_readonly_regions(binrec_t *handle);

/**
 * binrec_enable_branch_callback:  Set whether to call a function (pointed
 * to by the value at the PSB offset given by state_offset_branch_callback)
 * immediately before a branch to another instruction within the same
 * translation unit.  If enabled, the callback is called immediately before
 * taking a branch within the translated code; if the called function
 * returns zero, the translated code will return to its caller rather than
 * continuing execution at the branch target.   This can be used to safely
 * interrupt execution of the guest code ("safely" in the sense of the PSB
 * being fully updated) at a finer granularity than an entire translation
 * unit.  The callback is not called for conditional branches which are not
 * taken or for branches which would return from the translated code in any
 * case (such as indirect branches).
 *
 * The callback receives two parameters: the processor state block pointer
 * passed to the translated code and the address of the branch instruction,
 * and returns an int indicating whether to continue execution (nonzero) or
 * return from the translated code (zero).
 *
 * Note that the state of the PSB is indeterminate when the callback is
 * called; each register field will have either the same value it had at
 * the start of the unit or some value which was subsequently stored to
 * that register, but in general, register fields will not contain current
 * register values.  As an exception, the instruction pointer field (nia
 * for PowerPC hosts) will always contain the target address of the branch.
 * If the callback function returns zero to terminate execution, the PSB
 * will be updated as usual on exit from the translated code.
 *
 * Calling this function has no effect on already-translated code.
 *
 * By default, the branch callback is disabled.
 *
 * [Parameters]
 *     handle: Handle to operate on.
 *     enable: True (nonzero) to enable the branch callback, false (zero)
 *         to disable it.
 */
extern void binrec_enable_branch_callback(binrec_t *handle, int enable);

/**
 * binrec_set_pre_insn_callback:  Set a callback function which will be
 * called immediately before executing each guest instruction.  This can
 * be used, for example, to log an execution trace or to record the state
 * of the guest processor at a particular point.  Pass NULL to disable an
 * existing callback.
 *
 * The callback receives two parameters: the processor state block pointer
 * passed to the translated code and the address of the instruction about
 * to be executed.
 *
 * Calling this function has no effect on already-translated code.
 *
 * The pre- and post-instruction callbacks are generally useful only for
 * debugging or analysis of code at runtime, so they are set directly as
 * pointers in the runtime environment under the assumption that the host
 * architecture is that of the runtime environment.  These callbacks should
 * not be enabled when cross-compiling to a different architecture.
 *
 * Enabling the pre- or post-instruction callback can have a significant
 * negative impact on performance.
 *
 * [Parameters]
 *     handle: Handle to operate on.
 *     callback: Callback to install, or NULL to clear any installed callback.
 */
extern void binrec_set_pre_insn_callback(binrec_t *handle,
                                         void (*callback)(void *, uint32_t));

/**
 * binrec_set_post_insn_callback:  Set a callback function which will be
 * called immediately after executing each guest instruction.  The state
 * of the guest processor will be the same as if translation had ended
 * immediately after the just-executed instruction.  Pass NULL to disable
 * an existing callback.
 *
 * The callback receives two parameters: the processor state block pointer
 * passed to the translated code and the address of the instruction that
 * was just executed.
 *
 * If both this callback and the branch callback are enabled, this callback
 * will be called before the branch callback for taken intra-unit branches.
 *
 * Calling this function has no effect on already-translated code.
 *
 * [Parameters]
 *     handle: Handle to operate on.
 *     callback: Callback to install, or NULL to clear any installed callback.
 */
extern void binrec_set_post_insn_callback(binrec_t *handle,
                                          void (*callback)(void *, uint32_t));

/*************************************************************************/
/********************** Interface: Code translation **********************/
/*************************************************************************/

/**
 * binrec_translate:  Translate a block of guest machine code into native
 * machine code.
 *
 * The "address" and "limit" parameters specify the inclusive address
 * bounds from which instructions will be read for this call.  Translation
 * will stop when the translator reaches a source instruction which is not
 * entirely contained in the inclusive range [address,limit],  or when all
 * code paths starting from "address" have been translated (such as when
 * the end of a function in the input program is reached).  A value of -1
 * for "limit" allows translation to continue until such a natural endpoint
 * is found.
 *
 * The "state" parameter can be used to provide a processor state block
 * (of the same format as that passed to the generated code) for the
 * translation routines to reference.  This is used by certain
 * optimizations (currently only the PowerPC CONSTANT_GQRS optimization)
 * to generate more efficient code under the assumption that certain
 * elements of the processor state will remain constant for every call
 * to the translated code.  If NULL is passed, such optimizations will be
 * implicitly disabled for the current binrec_translate() call. 
 *
 * On success, the returned block can be executed by calling it as a
 * function with the following signature:
 *     void code(void *state, void *memory);
 * where the "state" parameter is a pointer to a processor state block
 * whose structure conforms to the structure offsets specified in the
 * setup data passed to binrec_create_handle(), and "memory" is a pointer
 * to the base of the guest memory region.
 *
 * The returned code pointer will have been allocated with the code_malloc
 * or code_realloc function passed in the setup structure to
 * binrec_create_handle(), or the relevant fallback function if code_*
 * functions were not supplied.
 *
 * Return-value arguments are only modified on a successful return.
 *
 * [Parameters]
 *     handle: Handle to use for translation.
 *     state: Guest processor state to reference for translation, or NULL
 *         if none.
 *     address: Address (in guest memory) of first instruction to translate.
 *     limit: Address (in guest memory) at which to terminate translation.
 *     code_ret: Pointer to variable to receive a pointer to the
 *         translated machine code.
 *     size_ret: Pointer to variable to receive the length of the
 *         translated machine code, in bytes.
 * [Return value]
 *     True (nonzero) on success, false (zero) on error.
 */
extern int binrec_translate(binrec_t *handle, void *state,
                            uint32_t address, uint32_t limit,
                            void **code_ret, long *size_ret);

/*************************************************************************/
/*************************************************************************/

#ifdef __cplusplus
}  // extern "C"
#endif

#endif  // BINREC_H
