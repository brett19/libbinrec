/*
 * libbinrec: a recompiling translator for machine code
 * Copyright (c) 2016 Andrew Church <achurch@achurch.org>
 *
 * This software may be copied and redistributed under certain conditions;
 * see the file "COPYING" in the source code distribution for details.
 * NO WARRANTY is provided with this software.
 */

/*
 * This file should be included in all tests that run the 750CL test
 * routine; it defines the data array for the routine itself and provides
 * appropriate handlers and setup code.  Call setup_750cl() to set up a
 * state block.
 */

#include "tests/ppc-lut.h"

/*************************************************************************/
/*************************** PowerPC test code ***************************/
/*************************************************************************/

/* This file is automatically generated with the contents of the test code.
 * The test source (ppc750cl.s) and the script used to generate this file
 * (gen-ppc750cl-bin.pl) live in the etc/ppc directory. */
#include "tests/guest-ppc/exec/ppc750cl-bin.i"

/* Constants for the test routine. */
#define PPC750CL_MEMORY_SIZE        0x2000000
#define PPC750CL_START_ADDRESS      0x1000000
#define PPC750CL_SCRATCH_ADDRESS    0x100000
#define PPC750CL_ERROR_LOG_ADDRESS  0x200000

/*************************************************************************/
/************************** Callback functions ***************************/
/*************************************************************************/

/* Handler for system call exceptions. */
static void sc_handler(PPCState *state)
{
    ASSERT(state);
    state->gpr[3] = 1;
}

/*-----------------------------------------------------------------------*/

/* Handler for timebase register reads.  Returns a value which increments
 * on each TBL or TBU read. */
static uint64_t timebase_handler(PPCState *state)
{
    ASSERT(state);
    return state->tb++;
}

/*-----------------------------------------------------------------------*/

/* Handler for trap exceptions. */
static void trap_handler(PPCState *state)
{
    ASSERT(state);
    state->gpr[3] = 0;
    state->nia += 4;  // Continue with the next instruction.
}

/*************************************************************************/
/************************* Test helper functions *************************/
/*************************************************************************/

/**
 * setup_750cl:  Set up a guest memory region and processor state block
 * for running the PowerPC 750CL test routine.
 *
 * [Parameters]
 *     state: Processor state block to initialize.
 * [Return value]
 *     Newly allocated guest memory region (free with free() when no
 *     longer needed).
 */
static void *setup_750cl(PPCState *state)
{
    uint8_t *memory;
    memory = malloc(PPC750CL_MEMORY_SIZE);
    if (!memory) {
        return NULL;
    }
    memset(memory, 0, PPC750CL_MEMORY_SIZE);
    memcpy(memory + PPC750CL_START_ADDRESS, ppc750cl_bin,
           sizeof(ppc750cl_bin));

    memset(state, 0, sizeof(*state));
    state->timebase_handler = timebase_handler;
    state->sc_handler = sc_handler;
    state->trap_handler = trap_handler;
    state->fres_lut = ppc_fres_lut;
    state->frsqrte_lut = ppc_frsqrte_lut;
    state->gpr[4] = PPC750CL_SCRATCH_ADDRESS;
    state->gpr[5] = PPC750CL_ERROR_LOG_ADDRESS;
    state->fpr[1][0] = 1.0;

    return memory;
}

/*-----------------------------------------------------------------------*/

/**
 * print_750cl_errors:  Print the error log from the 750CL test routine.
 *
 * [Parameters]
 *     count: Number of failure records returned from the test routine.
 *     memory: Pointer to guest memory region.
 */
static void print_750cl_errors(int count, void *memory)
{
    const uint32_t *error_log =
        (const uint32_t *)((uintptr_t)memory + PPC750CL_ERROR_LOG_ADDRESS);
    for (int i = 0; i < count; i++, error_log += 8) {
        const uint32_t insn = bswap_be32(error_log[0]);
        const uint32_t address = bswap_be32(error_log[1]);
        printf("    %08X %08X  %08X %08X  %08X %08X", insn, address,
               bswap_be32(error_log[2]), bswap_be32(error_log[3]),
               bswap_be32(error_log[4]), bswap_be32(error_log[5]));
        if ((insn & 0xFC00003E) == 0xFC000034) {  // frsqrte
            printf("  %08X %08X",
                   bswap_be32(error_log[6]), bswap_be32(error_log[7]));
        }
        printf("\n");
    }
}

/*************************************************************************/
/*************************************************************************/
