libbinrec: a recompiling translator for machine code
====================================================
Copyright (c) 2016 Andrew Church <achurch@achurch.org>
See the file "COPYING" for conditions on use and redistribution.

Version: 0.1


Overview
--------
libbinrec is a library for translating machine code from one CPU
architecture into equivalent and efficient machine code for a
different architecture, such as when emulating one CPU on another.
libbinrec is designed primarily for use in just-in-time (JIT)
compilation, which trades faster execution on average (translated code
can approach a 1:1 source-to-native instruction ratio, as opposed to
the dozens of native instructions which may be required to interpret
each source instruction on the fly) for additional overhead when
executing a block of code for the first time.

Currently, libbinrec only supports the PowerPC 32-bit instruction set
implemented in PowerPC 6xx/7xx processors as input and 64-bit x86
machine code as output.


Requirements
------------
libbinrec is written in pure C99 (with some additional compiler- and
architecture-specific code used to improve performance) and should
compile with any standards-compliant compiler.  The included Makefile is
written for GNU Make and supports building on Linux and other Unix-like
systems, Mac OS X, or Windows (MinGW), using Clang, GCC, or the Intel C
compiler.  libbinrec also includes a CMake (see <https://cmake.org/>)
control file for ease of integration into CMake-based projects.

libbinrec makes the following assumptions (beyond what is required by
C99) about the execution environment:
   - The environment uses two's-complement representations for signed
     integer values.
   - The exact-size integer types int8_t, int16_t, int32_t, and int64_t
     exist.
   - The "int" and "intptr_t" types are at least 32 bits wide.
   - The "float" and "double" types use IEEE 754 floating-point format.
There are currently no plans to support environments for which these do
not all hold.

The included tests assume for convenience that a null pointer is
represented by an all-zero bit pattern.


Building
--------
libbinrec can be built by simply running the "make" command (or "gmake",
if GNU Make is installed under that name on your system) in the top
directory of the libbinrec distribution.  This will create shared and
static library files in the top directory, which can then be installed
on the system with "make install".

Several configuration variables are available to control the build
process or specify nonstandard paths for dependent libraries.  These can
be set on the "make" command line; for example, "make ENABLE_ASSERT=1".
See the "Configuration" section at the top of the "Makefile" file for
details.


Using libbinrec
---------------
See the documentation in include/binrec.h for details.

When using libbinrec from a C++ program, the C++ header (binrec++.h) may
be more convenient; this header provides a "binrec" namespace for all
constants and functions, and wraps most functions in C++ classes for
convenience.


Limitations
-----------
libbinrec assumes that the input program it is given is valid machine
code for the selected input architecture (referred to as the "guest"
architecture in library documentation).  The library will correctly
detect and translate explicit illegal instructions, such as the x86 UD2
(0x0F 0x0B) or Motorola 68000 ILLEGAL (0x4AFC) instructions (note that
neither of these architectures are currently supported as guests) or the
all-zero PowerPC instruction word, but other byte sequences which do not
repesent a valid instruction for the guest architecture may result in
behavior different from a physical implementation of that architecture.
As a consequence, libbinrec may not correctly translate programs which
include deliberately invalid instruction encodings, such as to take
advantage of undocumented behavior of a specific architecture
implementation.

More generally, libbinrec is designed to translate between architectures
rather than hardware implementations; thus, as a rule, input code which
triggers behavior undefined in the architecture specification may behave
differently when translated by libbinrec than when run on a physical CPU
implementing the guest architecture.  For example, the PowerPC divide
instructions specify that the contents of the destination register are
undefined after divison by zero; libbinrec deliberately skips updating
the register state in this case, so the value eventually stored back to
the processor state block will depend on the structure of the translated
code.  This likely differs from the behavior of an actual PowerPC CPU,
but libbinrec does not attempt to match that behavior.

libbinrec is intended as a pure program translator rather than a
full-fledged architecture emulator, and consequently it does not support
translation of privileged instructions in the input program.
Non-privileged instructions which explicitly transfer control to a
privileged handler, such as the PowerPC sc (system call) instruction,
are translated by inserting a call to a handler function supplied by the
library user.  Similarly, libbinrec has no facility for handling
memory-mapped I/O; if such support is needed, the client program should
mark relevant regions of the guest memory space as unmapped on the host
system and use unmapped-access host exceptions to detect and handle such
accesses.  libbinrec also does not attempt to count instruction cycles
or otherwise reproduce precise timing behavior of the guest processor.


Reporting bugs
--------------
Please send any bug reports or suggestions directly to the author.
